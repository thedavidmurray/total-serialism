<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <title>Crystal Growth - Pen Plotter Art</title>
    <script src="../../../../preset-manager.js"></script>
    <link rel="stylesheet" href="../../../../preset-manager.css">
    
  <!-- Total Serialism Design System -->
  <link rel="stylesheet" href="../../shared/algorithm.css">
  <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #0a0a0a;
            color: #ffffff;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .controls {
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }
        
        .canvas-container {
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            background-color: #000000;
            border: 1px solid #333;
            cursor: crosshair;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        input[type="number"], select {
            width: 100%;
            background-color: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 5px;
            border-radius: 4px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background-color: #3a3a3a;
            border-color: #666;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .value-display {
            font-size: 11px;
            color: #666;
            text-align: right;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: normal;
            letter-spacing: 2px;
        }
        
        h3 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .progress {
            width: 100%;
            height: 4px;
            background-color: #0a0a0a;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4a4a4a;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <!-- Preset Manager Container -->
            <div id="preset-container"></div>

            <h3>Crystal Parameters</h3>

            <div class="control-group">
                <label for="crystalType">Crystal Type</label>
                <select id="crystalType">
                    <option value="dendritic">Dendritic (Snow)</option>
                    <option value="cubic">Cubic</option>
                    <option value="hexagonal">Hexagonal</option>
                    <option value="needle">Needle</option>
                    <option value="fractal">Fractal</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="seedPattern">Seed Pattern</label>
                <select id="seedPattern">
                    <option value="point">Single Point</option>
                    <option value="line">Line</option>
                    <option value="circle">Circle</option>
                    <option value="random">Random Points</option>
                    <option value="grid">Grid</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="particles">Number of Particles</label>
                <input type="range" id="particles" min="1000" max="50000" step="1000" value="10000">
                <div class="value-display" id="particlesValue">10000</div>
            </div>
            
            <div class="control-group">
                <label for="stickiness">Stickiness</label>
                <input type="range" id="stickiness" min="0.1" max="1" step="0.1" value="0.7">
                <div class="value-display" id="stickinessValue">0.7</div>
            </div>
            
            <div class="control-group">
                <label for="growthBias">Growth Bias</label>
                <input type="range" id="growthBias" min="0" max="2" step="0.1" value="1">
                <div class="value-display" id="growthBiasValue">1.0</div>
            </div>
            
            <div class="control-group">
                <label for="particleSize">Particle Size</label>
                <input type="range" id="particleSize" min="1" max="5" value="2">
                <div class="value-display" id="particleSizeValue">2</div>
            </div>
            
            <div class="control-group">
                <label for="colorMode">Color Mode</label>
                <select id="colorMode">
                    <option value="monochrome">Monochrome</option>
                    <option value="depth">Depth Based</option>
                    <option value="age">Age Based</option>
                    <option value="density">Density Based</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="symmetry">Symmetry</label>
                <select id="symmetry">
                    <option value="none">None</option>
                    <option value="2">2-fold</option>
                    <option value="4">4-fold</option>
                    <option value="6">6-fold</option>
                    <option value="8">8-fold</option>
                </select>
            </div>
            
            <div class="button-group">
                <button onclick="growCrystal()">Grow Crystal</button>
                <button onclick="clearCanvas()">Clear</button>
            </div>
            
            <div class="control-group">
                <label>Growth Progress</label>
                <div class="progress">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>
            
            <h3>Animation</h3>
            <div class="control-group">
                <label for="frameInterval">Frame Interval</label>
                <input type="range" id="frameInterval" min="100" max="2000" step="100" value="500">
                <div class="value-display" id="frameIntervalValue">500</div>
            </div>
            
            <button onclick="animateGrowth()">Animate Growth</button>
            
            <h3>Export Options</h3>
            <div class="export-buttons">
                <button onclick="exportSVG()">SVG</button>
                <button onclick="exportPNG()">PNG</button>
                <button onclick="exportGIF()">GIF</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <h1>CRYSTAL GROWTH</h1>
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let crystalData = [];
        let animationFrames = [];
        let isGrowing = false;
        let presetManager;

        // Parameters object for preset management
        const params = {
            crystalType: 'dendritic',
            seedPattern: 'point',
            particles: 10000,
            stickiness: 0.7,
            growthBias: 1.0,
            particleSize: 2,
            colorMode: 'monochrome',
            symmetry: 'none',
            frameInterval: 500
        };

        // Initialize preset manager when DOM is loaded
        window.addEventListener('DOMContentLoaded', () => {
            presetManager = new PresetManager({
                algorithmId: 'crystal-growth',
                container: '#preset-container',
                onSave: () => params,
                onLoad: (preset) => {
                    Object.assign(params, preset.data);
                    updateUIFromParams();
                },
                onRandomize: () => {
                    const crystalTypes = ['dendritic', 'cubic', 'hexagonal', 'needle', 'fractal'];
                    const seedPatterns = ['point', 'line', 'circle', 'random', 'grid'];
                    const colorModes = ['monochrome', 'depth', 'age', 'density'];
                    const symmetries = ['none', '2', '4', '6', '8'];

                    params.crystalType = crystalTypes[Math.floor(Math.random() * crystalTypes.length)];
                    params.seedPattern = seedPatterns[Math.floor(Math.random() * seedPatterns.length)];
                    params.particles = Math.floor(Math.random() * 49000) + 1000;
                    params.stickiness = Math.random() * 0.9 + 0.1;
                    params.growthBias = Math.random() * 2;
                    params.particleSize = Math.floor(Math.random() * 5) + 1;
                    params.colorMode = colorModes[Math.floor(Math.random() * colorModes.length)];
                    params.symmetry = symmetries[Math.floor(Math.random() * symmetries.length)];
                    params.frameInterval = Math.floor(Math.random() * 1900) + 100;

                    updateUIFromParams();
                }
            });
        });

        // Helper function to update UI from params
        function updateUIFromParams() {
            document.getElementById('crystalType').value = params.crystalType;
            document.getElementById('seedPattern').value = params.seedPattern;
            document.getElementById('particles').value = params.particles;
            document.getElementById('stickiness').value = params.stickiness;
            document.getElementById('growthBias').value = params.growthBias;
            document.getElementById('particleSize').value = params.particleSize;
            document.getElementById('colorMode').value = params.colorMode;
            document.getElementById('symmetry').value = params.symmetry;
            document.getElementById('frameInterval').value = params.frameInterval;

            // Update value displays
            document.getElementById('particlesValue').textContent = params.particles;
            document.getElementById('stickinessValue').textContent = params.stickiness;
            document.getElementById('growthBiasValue').textContent = params.growthBias.toFixed(1);
            document.getElementById('particleSizeValue').textContent = params.particleSize;
            document.getElementById('frameIntervalValue').textContent = params.frameInterval;
        }

        // Update value displays and params on input
        document.querySelectorAll('input[type="range"], select').forEach(input => {
            input.addEventListener('input', (e) => {
                const key = e.target.id;
                params[key] = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value;

                const valueDisplay = document.getElementById(key + 'Value');
                if (valueDisplay) {
                    valueDisplay.textContent = e.target.value;
                }
            });
        });
        
        class CrystalGrowth {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.grid = new Array(width * height).fill(0);
                this.particles = [];
                this.age = 0;
            }
            
            initializeSeed() {
                const seedPattern = document.getElementById('seedPattern').value;
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                switch(seedPattern) {
                    case 'point':
                        this.addParticle(centerX, centerY);
                        break;
                    case 'line':
                        for (let x = centerX - 50; x <= centerX + 50; x++) {
                            this.addParticle(x, centerY);
                        }
                        break;
                    case 'circle':
                        const radius = 30;
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                            const x = centerX + Math.cos(angle) * radius;
                            const y = centerY + Math.sin(angle) * radius;
                            this.addParticle(Math.round(x), Math.round(y));
                        }
                        break;
                    case 'random':
                        for (let i = 0; i < 10; i++) {
                            const x = centerX + (Math.random() - 0.5) * 100;
                            const y = centerY + (Math.random() - 0.5) * 100;
                            this.addParticle(Math.round(x), Math.round(y));
                        }
                        break;
                    case 'grid':
                        for (let x = -2; x <= 2; x++) {
                            for (let y = -2; y <= 2; y++) {
                                this.addParticle(centerX + x * 20, centerY + y * 20);
                            }
                        }
                        break;
                }
            }
            
            addParticle(x, y) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    const index = y * this.width + x;
                    this.grid[index] = 1;
                    this.particles.push({x, y, age: this.age});
                }
            }
            
            checkNeighbors(x, y) {
                const crystalType = document.getElementById('crystalType').value;
                let neighbors = 0;
                let directions;
                
                switch(crystalType) {
                    case 'cubic':
                        directions = [[-1,0], [1,0], [0,-1], [0,1]];
                        break;
                    case 'hexagonal':
                        directions = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [1,1]];
                        break;
                    default:
                        directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                }
                
                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                        if (this.grid[ny * this.width + nx] === 1) {
                            neighbors++;
                        }
                    }
                }
                
                return neighbors;
            }
            
            growStep(numParticles) {
                const stickiness = parseFloat(document.getElementById('stickiness').value);
                const growthBias = parseFloat(document.getElementById('growthBias').value);
                const symmetry = parseInt(document.getElementById('symmetry').value);
                
                let added = 0;
                let attempts = 0;
                
                while (added < numParticles && attempts < numParticles * 100) {
                    attempts++;
                    
                    // Random walker
                    let x, y;
                    const edge = Math.floor(Math.random() * 4);
                    switch(edge) {
                        case 0: x = 0; y = Math.floor(Math.random() * this.height); break;
                        case 1: x = this.width - 1; y = Math.floor(Math.random() * this.height); break;
                        case 2: x = Math.floor(Math.random() * this.width); y = 0; break;
                        case 3: x = Math.floor(Math.random() * this.width); y = this.height - 1; break;
                    }
                    
                    // Random walk until hits crystal or leaves bounds
                    let steps = 0;
                    while (steps < 1000) {
                        // Biased random walk towards center
                        const centerX = this.width / 2;
                        const centerY = this.height / 2;
                        const dx = centerX - x;
                        const dy = centerY - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            x += Math.random() < growthBias * 0.5 ? Math.sign(dx) : (Math.random() - 0.5) * 2;
                            y += Math.random() < growthBias * 0.5 ? Math.sign(dy) : (Math.random() - 0.5) * 2;
                        } else {
                            x += (Math.random() - 0.5) * 2;
                            y += (Math.random() - 0.5) * 2;
                        }
                        
                        x = Math.round(x);
                        y = Math.round(y);
                        
                        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                            break;
                        }
                        
                        const neighbors = this.checkNeighbors(x, y);
                        if (neighbors > 0 && Math.random() < stickiness) {
                            this.addParticle(x, y);
                            
                            // Add symmetric particles
                            if (symmetry > 1) {
                                const cx = this.width / 2;
                                const cy = this.height / 2;
                                const angle = Math.atan2(y - cy, x - cx);
                                const radius = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                                
                                for (let i = 1; i < symmetry; i++) {
                                    const newAngle = angle + (Math.PI * 2 * i / symmetry);
                                    const sx = Math.round(cx + Math.cos(newAngle) * radius);
                                    const sy = Math.round(cy + Math.sin(newAngle) * radius);
                                    this.addParticle(sx, sy);
                                }
                            }
                            
                            added++;
                            break;
                        }
                        
                        steps++;
                    }
                }
                
                this.age++;
                return added;
            }
            
            draw(ctx) {
                const colorMode = document.getElementById('colorMode').value;
                const particleSize = parseInt(document.getElementById('particleSize').value);
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.particles.forEach(particle => {
                    let color;
                    
                    switch(colorMode) {
                        case 'monochrome':
                            color = '#ffffff';
                            break;
                        case 'depth':
                            const depth = Math.sqrt((particle.x - this.width/2) ** 2 + 
                                                  (particle.y - this.height/2) ** 2);
                            const hue = (depth / (this.width/2)) * 240;
                            color = `hsl(${hue}, 70%, 50%)`;
                            break;
                        case 'age':
                            const ageRatio = particle.age / this.age;
                            color = `hsl(${ageRatio * 300}, 70%, 50%)`;
                            break;
                        case 'density':
                            const density = this.checkNeighbors(particle.x, particle.y) / 8;
                            const brightness = 30 + density * 70;
                            color = `hsl(200, 70%, ${brightness}%)`;
                            break;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(particle.x - particleSize/2, particle.y - particleSize/2, 
                               particleSize, particleSize);
                });
            }
        }
        
        async function growCrystal() {
            if (isGrowing) return;
            isGrowing = true;
            
            clearCanvas();
            const crystal = new CrystalGrowth(canvas.width, canvas.height);
            crystal.initializeSeed();
            
            const totalParticles = parseInt(document.getElementById('particles').value);
            const batchSize = 100;
            let grown = 0;
            
            crystalData = crystal;
            
            const growBatch = () => {
                if (grown < totalParticles && isGrowing) {
                    const added = crystal.growStep(Math.min(batchSize, totalParticles - grown));
                    grown += added;
                    
                    // Update progress
                    const progress = (grown / totalParticles) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    
                    // Draw current state
                    crystal.draw(ctx);
                    
                    requestAnimationFrame(growBatch);
                } else {
                    isGrowing = false;
                    document.getElementById('progressBar').style.width = '0%';
                }
            };
            
            growBatch();
        }
        
        async function animateGrowth() {
            if (isGrowing) return;
            isGrowing = true;
            
            animationFrames = [];
            clearCanvas();
            
            const crystal = new CrystalGrowth(canvas.width, canvas.height);
            crystal.initializeSeed();
            
            const totalParticles = parseInt(document.getElementById('particles').value);
            const frameInterval = parseInt(document.getElementById('frameInterval').value);
            const framesPerCapture = Math.floor(frameInterval / 100);
            
            crystalData = crystal;
            
            let grown = 0;
            let frameCount = 0;
            
            const growFrame = () => {
                if (grown < totalParticles && isGrowing) {
                    const added = crystal.growStep(frameInterval);
                    grown += added;
                    frameCount++;
                    
                    // Update progress
                    const progress = (grown / totalParticles) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    
                    // Draw and capture frame
                    crystal.draw(ctx);
                    
                    if (frameCount % framesPerCapture === 0) {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        animationFrames.push(imageData);
                    }
                    
                    setTimeout(growFrame, 50);
                } else {
                    isGrowing = false;
                    document.getElementById('progressBar').style.width = '0%';
                }
            };
            
            growFrame();
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            crystalData = null;
            animationFrames = [];
            isGrowing = false;
            document.getElementById('progressBar').style.width = '0%';
        }
        
        function exportSVG() {
            if (!crystalData || crystalData.particles.length === 0) return;
            
            const particleSize = parseInt(document.getElementById('particleSize').value);
            
            let svg = `<svg width="${canvas.width}" height="${canvas.height}" xmlns="http://www.w3.org/2000/svg">`;
            svg += `<rect width="${canvas.width}" height="${canvas.height}" fill="#000000"/>`;
            
            crystalData.particles.forEach(particle => {
                svg += `<rect x="${particle.x - particleSize/2}" y="${particle.y - particleSize/2}" `;
                svg += `width="${particleSize}" height="${particleSize}" fill="white"/>`;
            });
            
            svg += '</svg>';
            
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'crystal.svg';
            a.click();
        }
        
        function exportPNG() {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'crystal.png';
                a.click();
            });
        }
        
        function exportGIF() {
            if (animationFrames.length === 0) {
                alert('Please animate the growth first!');
                return;
            }
            
            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: canvas.width,
                height: canvas.height
            });
            
            animationFrames.forEach(frame => {
                gif.addFrame(frame, {delay: 100});
            });
            
            gif.on('finished', blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'crystal-growth.gif';
                a.click();
            });
            
            gif.render();
        }
        
        // Click to add seed point
        canvas.addEventListener('click', (e) => {
            if (!crystalData || isGrowing) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            
            crystalData.addParticle(x, y);
            crystalData.draw(ctx);
        });
    </script>
</body>
</html>