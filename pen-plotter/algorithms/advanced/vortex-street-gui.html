<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kármán Vortex Street Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="../../../../preset-manager.js"></script>
    <link rel="stylesheet" href="../../../../preset-manager.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 300px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"], select {
            width: 100%;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button.stop {
            background: #f44336;
        }
        button.stop:hover {
            background: #da190b;
        }
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
        }
        .info-display {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Vortex Street Controls</h3>

        <!-- Preset Manager Container -->
        <div id="preset-container"></div>

        <div class="control-group">
            <label>Obstacle Shape:</label>
            <select id="obstacleShape">
                <option value="cylinder">Cylinder</option>
                <option value="square">Square</option>
                <option value="airfoil">Airfoil</option>
                <option value="triangle">Triangle</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Reynolds Number: <span id="reynoldsValue" class="value-display">150</span></label>
            <input type="range" id="reynolds" min="10" max="500" value="150" step="10">
        </div>
        
        <div class="control-group">
            <label>Flow Speed: <span id="flowSpeedValue" class="value-display">2.0</span></label>
            <input type="range" id="flowSpeed" min="0.5" max="5" value="2" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Obstacle Size: <span id="obstacleSizeValue" class="value-display">40</span></label>
            <input type="range" id="obstacleSize" min="20" max="80" value="40" step="5">
        </div>
        
        <div class="control-group">
            <label>Visualization:</label>
            <select id="vizMode">
                <option value="streamlines">Streamlines</option>
                <option value="vorticity">Vorticity</option>
                <option value="pressure">Pressure Field</option>
                <option value="velocity">Velocity Magnitude</option>
                <option value="combined">Combined View</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Resolution: <span id="resolutionValue" class="value-display">64</span></label>
            <select id="resolution">
                <option value="32">32</option>
                <option value="64" selected>64</option>
                <option value="128">128</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Vortex Shedding: <span id="sheddingValue" class="value-display">0.2</span></label>
            <input type="range" id="shedding" min="0.1" max="0.5" value="0.2" step="0.01">
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="showVectors" checked> Show Velocity Vectors
            </label>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="showTrails"> Show Particle Trails
            </label>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="animate" checked> Animate Flow
            </label>
        </div>
        
        <div class="info-display">
            Strouhal Number: <span id="strouhalNumber">0.21</span><br>
            Vortex Frequency: <span id="vortexFreq">2.1</span> Hz
        </div>
        
        <button onclick="resetSimulation()">Reset Flow</button>
        <button onclick="exportSVG()">Export SVG</button>
        <button onclick="toggleAnimation()" id="animButton" class="stop">Pause</button>
    </div>

    <script>
        let fluid;
        let particles = [];
        let streamlines = [];
        let vortices = [];
        let time = 0;
        let presetManager;

        let params = {
            obstacleShape: 'cylinder',
            reynolds: 150,
            flowSpeed: 2.0,
            obstacleSize: 40,
            vizMode: 'streamlines',
            resolution: 64,
            shedding: 0.2,
            showVectors: true,
            showTrails: false,
            animate: true
        };
        
        class FluidSimulation {
            constructor(res) {
                this.res = res;
                this.size = width / res;
                this.u = []; // x-velocity
                this.v = []; // y-velocity
                this.p = []; // pressure
                this.vort = []; // vorticity
                
                // Initialize fields
                for (let i = 0; i < res; i++) {
                    this.u[i] = [];
                    this.v[i] = [];
                    this.p[i] = [];
                    this.vort[i] = [];
                    for (let j = 0; j < res; j++) {
                        this.u[i][j] = params.flowSpeed;
                        this.v[i][j] = 0;
                        this.p[i][j] = 0;
                        this.vort[i][j] = 0;
                    }
                }
            }
            
            update() {
                // Simplified fluid dynamics
                const dt = 0.01;
                const visc = 1.0 / params.reynolds;
                
                // Apply boundary conditions
                this.applyBoundaries();
                
                // Advection
                this.advect(dt);
                
                // Diffusion
                this.diffuse(dt, visc);
                
                // Pressure correction
                this.pressureCorrection();
                
                // Calculate vorticity
                this.calculateVorticity();
                
                // Add vortex shedding
                this.addVortexShedding();
            }
            
            applyBoundaries() {
                const cx = this.res / 4;
                const cy = this.res / 2;
                const r = params.obstacleSize / (width / this.res) / 2;
                
                for (let i = 0; i < this.res; i++) {
                    for (let j = 0; j < this.res; j++) {
                        const dx = i - cx;
                        const dy = j - cy;
                        
                        let inside = false;
                        
                        switch(params.obstacleShape) {
                            case 'cylinder':
                                inside = (dx * dx + dy * dy) < r * r;
                                break;
                            case 'square':
                                inside = abs(dx) < r && abs(dy) < r;
                                break;
                            case 'airfoil':
                                // NACA 0012 approximation
                                const x = dx / r;
                                const t = 0.12;
                                const yMax = t * (0.2969 * sqrt(abs(x)) - 0.126 * x - 0.3516 * x * x + 0.2843 * x * x * x - 0.1015 * x * x * x * x);
                                inside = abs(x) <= 1 && abs(dy / r) <= yMax;
                                break;
                            case 'triangle':
                                inside = dx > -r && dx < r && dy > -r && dy < r - 2 * dx;
                                break;
                        }
                        
                        if (inside) {
                            this.u[i][j] = 0;
                            this.v[i][j] = 0;
                        }
                        
                        // Inlet boundary
                        if (i === 0) {
                            this.u[i][j] = params.flowSpeed;
                            this.v[i][j] = 0;
                        }
                        
                        // Top and bottom boundaries
                        if (j === 0 || j === this.res - 1) {
                            this.v[i][j] = 0;
                        }
                    }
                }
            }
            
            advect(dt) {
                const newU = [];
                const newV = [];
                
                for (let i = 0; i < this.res; i++) {
                    newU[i] = [];
                    newV[i] = [];
                    for (let j = 0; j < this.res; j++) {
                        // Back-trace particle position
                        const x = i - this.u[i][j] * dt;
                        const y = j - this.v[i][j] * dt;
                        
                        // Bilinear interpolation
                        const i0 = floor(constrain(x, 0, this.res - 2));
                        const j0 = floor(constrain(y, 0, this.res - 2));
                        const i1 = i0 + 1;
                        const j1 = j0 + 1;
                        
                        const sx = x - i0;
                        const sy = y - j0;
                        
                        newU[i][j] = (1 - sx) * (1 - sy) * this.u[i0][j0] +
                                    sx * (1 - sy) * this.u[i1][j0] +
                                    (1 - sx) * sy * this.u[i0][j1] +
                                    sx * sy * this.u[i1][j1];
                                    
                        newV[i][j] = (1 - sx) * (1 - sy) * this.v[i0][j0] +
                                    sx * (1 - sy) * this.v[i1][j0] +
                                    (1 - sx) * sy * this.v[i0][j1] +
                                    sx * sy * this.v[i1][j1];
                    }
                }
                
                this.u = newU;
                this.v = newV;
            }
            
            diffuse(dt, visc) {
                // Simplified diffusion using Jacobi iteration
                const alpha = dt * visc * this.res * this.res;
                
                for (let iter = 0; iter < 20; iter++) {
                    const newU = [];
                    const newV = [];
                    
                    for (let i = 1; i < this.res - 1; i++) {
                        newU[i] = [];
                        newV[i] = [];
                        for (let j = 1; j < this.res - 1; j++) {
                            newU[i][j] = (this.u[i][j] + alpha * (
                                this.u[i-1][j] + this.u[i+1][j] +
                                this.u[i][j-1] + this.u[i][j+1]
                            )) / (1 + 4 * alpha);
                            
                            newV[i][j] = (this.v[i][j] + alpha * (
                                this.v[i-1][j] + this.v[i+1][j] +
                                this.v[i][j-1] + this.v[i][j+1]
                            )) / (1 + 4 * alpha);
                        }
                    }
                    
                    // Update interior points
                    for (let i = 1; i < this.res - 1; i++) {
                        for (let j = 1; j < this.res - 1; j++) {
                            this.u[i][j] = newU[i][j];
                            this.v[i][j] = newV[i][j];
                        }
                    }
                }
            }
            
            pressureCorrection() {
                // Calculate divergence
                const div = [];
                for (let i = 0; i < this.res; i++) {
                    div[i] = [];
                    for (let j = 0; j < this.res; j++) {
                        if (i > 0 && i < this.res - 1 && j > 0 && j < this.res - 1) {
                            div[i][j] = (this.u[i+1][j] - this.u[i-1][j] +
                                        this.v[i][j+1] - this.v[i][j-1]) * 0.5;
                        } else {
                            div[i][j] = 0;
                        }
                    }
                }
                
                // Solve for pressure (simplified)
                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.res - 1; i++) {
                        for (let j = 1; j < this.res - 1; j++) {
                            this.p[i][j] = (this.p[i-1][j] + this.p[i+1][j] +
                                           this.p[i][j-1] + this.p[i][j+1] -
                                           div[i][j]) * 0.25;
                        }
                    }
                }
                
                // Apply pressure gradient
                for (let i = 1; i < this.res - 1; i++) {
                    for (let j = 1; j < this.res - 1; j++) {
                        this.u[i][j] -= (this.p[i+1][j] - this.p[i-1][j]) * 0.5;
                        this.v[i][j] -= (this.p[i][j+1] - this.p[i][j-1]) * 0.5;
                    }
                }
            }
            
            calculateVorticity() {
                for (let i = 1; i < this.res - 1; i++) {
                    for (let j = 1; j < this.res - 1; j++) {
                        const dudy = (this.u[i][j+1] - this.u[i][j-1]) * 0.5;
                        const dvdx = (this.v[i+1][j] - this.v[i-1][j]) * 0.5;
                        this.vort[i][j] = dvdx - dudy;
                    }
                }
            }
            
            addVortexShedding() {
                // Add alternating vortices behind obstacle
                const cx = this.res / 4;
                const cy = this.res / 2;
                const r = params.obstacleSize / (width / this.res) / 2;
                
                const phase = sin(time * params.shedding * 10);
                const vortexStrength = params.shedding * phase;
                
                // Add vortices at separation points
                const sepX = cx + r + 2;
                const sepY1 = cy + r * 0.7;
                const sepY2 = cy - r * 0.7;
                
                if (sepX < this.res - 1) {
                    this.v[sepX][floor(sepY1)] += vortexStrength;
                    this.v[sepX][floor(sepY2)] -= vortexStrength;
                }
            }
        }
        
        function setup() {
            createCanvas(windowWidth - 350, windowHeight - 40);
            setupControls();

            // Initialize preset manager
            presetManager = new PresetManager({
                algorithmId: 'vortex-street',
                container: '#preset-container',
                onSave: () => params,
                onLoad: (preset) => {
                    Object.assign(params, preset.data);
                    updateUIFromParams();
                    resetSimulation();
                },
                onRandomize: () => {
                    const shapes = ['cylinder', 'square', 'airfoil', 'triangle'];
                    const vizModes = ['streamlines', 'vorticity', 'pressure', 'velocity', 'combined'];
                    params.obstacleShape = random(shapes);
                    params.reynolds = Math.floor(random(10, 500));
                    params.flowSpeed = random(0.5, 5);
                    params.obstacleSize = Math.floor(random(20, 80));
                    params.vizMode = random(vizModes);
                    params.resolution = random([32, 64, 128]);
                    params.shedding = random(0.1, 0.5);
                    params.showVectors = random() > 0.5;
                    params.showTrails = random() > 0.5;
                    params.animate = true;
                    updateUIFromParams();
                    resetSimulation();
                }
            });

            resetSimulation();
        }

        // Helper function to update UI from params
        function updateUIFromParams() {
            document.getElementById('obstacleShape').value = params.obstacleShape;
            document.getElementById('reynolds').value = params.reynolds;
            document.getElementById('flowSpeed').value = params.flowSpeed;
            document.getElementById('obstacleSize').value = params.obstacleSize;
            document.getElementById('vizMode').value = params.vizMode;
            document.getElementById('resolution').value = params.resolution;
            document.getElementById('shedding').value = params.shedding;
            document.getElementById('showVectors').checked = params.showVectors;
            document.getElementById('showTrails').checked = params.showTrails;
            document.getElementById('animate').checked = params.animate;

            // Update value displays
            document.getElementById('reynoldsValue').textContent = params.reynolds;
            document.getElementById('flowSpeedValue').textContent = params.flowSpeed.toFixed(1);
            document.getElementById('obstacleSizeValue').textContent = params.obstacleSize;
            document.getElementById('resolutionValue').textContent = params.resolution;
            document.getElementById('sheddingValue').textContent = params.shedding.toFixed(2);
        }
        
        function setupControls() {
            // Obstacle shape
            document.getElementById('obstacleShape').addEventListener('change', (e) => {
                params.obstacleShape = e.target.value;
                resetSimulation();
            });
            
            // Reynolds number
            document.getElementById('reynolds').addEventListener('input', (e) => {
                params.reynolds = parseInt(e.target.value);
                document.getElementById('reynoldsValue').textContent = e.target.value;
                updateInfo();
            });
            
            // Flow speed
            document.getElementById('flowSpeed').addEventListener('input', (e) => {
                params.flowSpeed = parseFloat(e.target.value);
                document.getElementById('flowSpeedValue').textContent = e.target.value;
                updateInfo();
            });
            
            // Obstacle size
            document.getElementById('obstacleSize').addEventListener('input', (e) => {
                params.obstacleSize = parseInt(e.target.value);
                document.getElementById('obstacleSizeValue').textContent = e.target.value;
                resetSimulation();
            });
            
            // Visualization mode
            document.getElementById('vizMode').addEventListener('change', (e) => {
                params.vizMode = e.target.value;
            });
            
            // Resolution
            document.getElementById('resolution').addEventListener('change', (e) => {
                params.resolution = parseInt(e.target.value);
                document.getElementById('resolutionValue').textContent = e.target.value;
                resetSimulation();
            });
            
            // Vortex shedding
            document.getElementById('shedding').addEventListener('input', (e) => {
                params.shedding = parseFloat(e.target.value);
                document.getElementById('sheddingValue').textContent = e.target.value;
            });
            
            // Checkboxes
            document.getElementById('showVectors').addEventListener('change', (e) => {
                params.showVectors = e.target.checked;
            });
            
            document.getElementById('showTrails').addEventListener('change', (e) => {
                params.showTrails = e.target.checked;
                if (!params.showTrails) {
                    particles = [];
                }
            });
            
            document.getElementById('animate').addEventListener('change', (e) => {
                params.animate = e.target.checked;
            });
        }
        
        function resetSimulation() {
            fluid = new FluidSimulation(params.resolution);
            particles = [];
            streamlines = [];
            vortices = [];
            time = 0;
            
            // Initialize particles for trails
            if (params.showTrails) {
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: random(width),
                        y: random(height),
                        history: []
                    });
                }
            }
            
            updateInfo();
        }
        
        function updateInfo() {
            // Calculate Strouhal number (St = fD/U)
            const D = params.obstacleSize;
            const U = params.flowSpeed;
            const f = params.shedding * U / D; // Simplified
            const St = f * D / U;
            
            document.getElementById('strouhalNumber').textContent = St.toFixed(2);
            document.getElementById('vortexFreq').textContent = f.toFixed(1);
        }
        
        function draw() {
            background(240);
            
            if (params.animate) {
                // Update fluid simulation
                fluid.update();
                time += 0.016; // ~60fps
                
                // Update particles
                updateParticles();
            }
            
            // Draw based on visualization mode
            switch(params.vizMode) {
                case 'streamlines':
                    drawStreamlines();
                    break;
                case 'vorticity':
                    drawVorticity();
                    break;
                case 'pressure':
                    drawPressure();
                    break;
                case 'velocity':
                    drawVelocityMagnitude();
                    break;
                case 'combined':
                    drawCombined();
                    break;
            }
            
            // Draw obstacle
            drawObstacle();
            
            // Draw velocity vectors
            if (params.showVectors) {
                drawVelocityVectors();
            }
            
            // Draw particle trails
            if (params.showTrails) {
                drawParticleTrails();
            }
        }
        
        function drawStreamlines() {
            stroke(0, 100);
            strokeWeight(1);
            noFill();
            
            const spacing = 10;
            
            for (let y = spacing; y < height; y += spacing) {
                beginShape();
                let x = 0;
                let cy = y;
                
                while (x < width && cy > 0 && cy < height) {
                    vertex(x, cy);
                    
                    // Get velocity at this point
                    const i = constrain(floor(x / fluid.size), 0, fluid.res - 1);
                    const j = constrain(floor(cy / fluid.size), 0, fluid.res - 1);
                    
                    const u = fluid.u[i][j] * fluid.size;
                    const v = fluid.v[i][j] * fluid.size;
                    
                    x += u * 0.5;
                    cy += v * 0.5;
                    
                    if (abs(u) < 0.01 && abs(v) < 0.01) break;
                }
                endShape();
            }
        }
        
        function drawVorticity() {
            noStroke();
            
            for (let i = 0; i < fluid.res; i++) {
                for (let j = 0; j < fluid.res; j++) {
                    const vort = fluid.vort[i][j];
                    const x = i * fluid.size;
                    const y = j * fluid.size;
                    
                    if (vort > 0) {
                        fill(255, 0, 0, abs(vort) * 1000);
                    } else {
                        fill(0, 0, 255, abs(vort) * 1000);
                    }
                    
                    rect(x, y, fluid.size, fluid.size);
                }
            }
        }
        
        function drawPressure() {
            noStroke();
            
            for (let i = 0; i < fluid.res; i++) {
                for (let j = 0; j < fluid.res; j++) {
                    const p = fluid.p[i][j];
                    const x = i * fluid.size;
                    const y = j * fluid.size;
                    
                    const c = map(p, -1, 1, 0, 255);
                    fill(c, c, 255 - c);
                    
                    rect(x, y, fluid.size, fluid.size);
                }
            }
        }
        
        function drawVelocityMagnitude() {
            noStroke();
            
            for (let i = 0; i < fluid.res; i++) {
                for (let j = 0; j < fluid.res; j++) {
                    const u = fluid.u[i][j];
                    const v = fluid.v[i][j];
                    const mag = sqrt(u * u + v * v);
                    const x = i * fluid.size;
                    const y = j * fluid.size;
                    
                    const c = map(mag, 0, params.flowSpeed * 2, 0, 255);
                    fill(255 - c, 255 - c, 255);
                    
                    rect(x, y, fluid.size, fluid.size);
                }
            }
        }
        
        function drawCombined() {
            // Draw velocity magnitude as background
            drawVelocityMagnitude();
            
            // Overlay streamlines
            stroke(0, 150);
            strokeWeight(1);
            drawStreamlines();
        }
        
        function drawObstacle() {
            fill(50);
            noStroke();
            
            const cx = width / 4;
            const cy = height / 2;
            const r = params.obstacleSize;
            
            push();
            translate(cx, cy);
            
            switch(params.obstacleShape) {
                case 'cylinder':
                    ellipse(0, 0, r, r);
                    break;
                case 'square':
                    rectMode(CENTER);
                    rect(0, 0, r, r);
                    break;
                case 'airfoil':
                    // NACA 0012 shape
                    beginShape();
                    for (let x = -1; x <= 1; x += 0.05) {
                        const t = 0.12;
                        const y = t * 5 * (0.2969 * sqrt(abs(x)) - 0.126 * x - 0.3516 * x * x + 0.2843 * x * x * x - 0.1015 * x * x * x * x);
                        vertex(x * r/2, y * r);
                    }
                    for (let x = 1; x >= -1; x -= 0.05) {
                        const t = 0.12;
                        const y = -t * 5 * (0.2969 * sqrt(abs(x)) - 0.126 * x - 0.3516 * x * x + 0.2843 * x * x * x - 0.1015 * x * x * x * x);
                        vertex(x * r/2, y * r);
                    }
                    endShape(CLOSE);
                    break;
                case 'triangle':
                    triangle(-r/2, r/2, r/2, r/2, 0, -r/2);
                    break;
            }
            
            pop();
        }
        
        function drawVelocityVectors() {
            stroke(0, 150);
            strokeWeight(1);
            
            const spacing = 20;
            const scale = 10;
            
            for (let x = 0; x < width; x += spacing) {
                for (let y = 0; y < height; y += spacing) {
                    const i = constrain(floor(x / fluid.size), 0, fluid.res - 1);
                    const j = constrain(floor(y / fluid.size), 0, fluid.res - 1);
                    
                    const u = fluid.u[i][j] * scale;
                    const v = fluid.v[i][j] * scale;
                    
                    line(x, y, x + u, y + v);
                    
                    // Arrowhead
                    push();
                    translate(x + u, y + v);
                    rotate(atan2(v, u));
                    line(0, 0, -3, -2);
                    line(0, 0, -3, 2);
                    pop();
                }
            }
        }
        
        function updateParticles() {
            for (let p of particles) {
                const i = constrain(floor(p.x / fluid.size), 0, fluid.res - 1);
                const j = constrain(floor(p.y / fluid.size), 0, fluid.res - 1);
                
                const u = fluid.u[i][j] * fluid.size;
                const v = fluid.v[i][j] * fluid.size;
                
                p.x += u;
                p.y += v;
                
                // Add to history
                p.history.push({x: p.x, y: p.y});
                if (p.history.length > 50) {
                    p.history.shift();
                }
                
                // Reset if out of bounds
                if (p.x > width || p.x < 0 || p.y > height || p.y < 0) {
                    p.x = 0;
                    p.y = random(height);
                    p.history = [];
                }
            }
        }
        
        function drawParticleTrails() {
            noFill();
            
            for (let p of particles) {
                stroke(0, 100);
                strokeWeight(1);
                
                beginShape();
                for (let h of p.history) {
                    vertex(h.x, h.y);
                }
                endShape();
                
                // Draw particle
                stroke(255, 0, 0);
                strokeWeight(3);
                point(p.x, p.y);
            }
        }
        
        function toggleAnimation() {
            params.animate = !params.animate;
            const btn = document.getElementById('animButton');
            btn.textContent = params.animate ? 'Pause' : 'Play';
            btn.className = params.animate ? 'stop' : '';
        }
        
        function exportSVG() {
            const svg = createSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vortex-street-${params.obstacleShape}-Re${params.reynolds}-${Date.now()}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function createSVG() {
            const svgSize = 800;
            
            let svg = `<svg width="${svgSize}" height="${svgSize}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<rect width="${svgSize}" height="${svgSize}" fill="white"/>\n`;
            
            // Export streamlines
            if (params.vizMode === 'streamlines' || params.vizMode === 'combined') {
                svg += `<g stroke="black" stroke-width="1" fill="none">\n`;
                
                const spacing = 20;
                const scale = svgSize / width;
                
                for (let y = spacing; y < height; y += spacing * 2) {
                    svg += `<path d="M `;
                    
                    let x = 0;
                    let cy = y;
                    let pathData = '';
                    
                    while (x < width && cy > 0 && cy < height) {
                        pathData += `${x * scale} ${cy * scale} `;
                        
                        const i = constrain(floor(x / fluid.size), 0, fluid.res - 1);
                        const j = constrain(floor(cy / fluid.size), 0, fluid.res - 1);
                        
                        const u = fluid.u[i][j] * fluid.size;
                        const v = fluid.v[i][j] * fluid.size;
                        
                        x += u * 0.5;
                        cy += v * 0.5;
                        
                        if (abs(u) < 0.01 && abs(v) < 0.01) break;
                    }
                    
                    svg += pathData + `"/>\n`;
                }
                
                svg += `</g>\n`;
            }
            
            // Export obstacle
            const cx = svgSize / 4;
            const cy = svgSize / 2;
            const r = params.obstacleSize * svgSize / width;
            
            svg += `<g fill="black">\n`;
            
            switch(params.obstacleShape) {
                case 'cylinder':
                    svg += `<circle cx="${cx}" cy="${cy}" r="${r/2}"/>\n`;
                    break;
                case 'square':
                    svg += `<rect x="${cx - r/2}" y="${cy - r/2}" width="${r}" height="${r}"/>\n`;
                    break;
                case 'triangle':
                    svg += `<polygon points="${cx - r/2},${cy + r/2} ${cx + r/2},${cy + r/2} ${cx},${cy - r/2}"/>\n`;
                    break;
            }
            
            svg += `</g>\n`;
            svg += `</svg>`;
            
            return svg;
        }
        
        function windowResized() {
            resizeCanvas(windowWidth - 350, windowHeight - 40);
            resetSimulation();
        }
    </script>
</body>
</html>