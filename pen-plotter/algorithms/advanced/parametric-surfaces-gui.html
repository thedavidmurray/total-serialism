<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <title>Parametric Surfaces - 3D to 2D Projection</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="../../preset-manager.js"></script>
    <link rel="stylesheet" href="../../preset-manager.css">
    <script src="../../shared/canvas-layout.js"></script>
  <script src="../../shared/canvas-controls.js"></script>
    <script src="../../shared/export-utils.js"></script>

  <!-- Total Serialism Design System -->
  <link rel="stylesheet" href="../../shared/algorithm.css">
  <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"], select {
            width: 100%;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
        }
    </style>
</head>
<body>
  <a href="../../index.html" class="back-link">Back to Index</a>

    <div id="controls">
        <h3>Parametric Surface Controls</h3>

        <!-- Preset Manager Container -->
        <div id="preset-container"></div>

        <div class="control-group">
            <label>Canvas Settings</label>
            <select id="paperSize">
                <option value="square800">Square (800Ã—800)</option>
                <option value="landscape800x600">Landscape (800Ã—600)</option>
                <option value="a4portrait">A4 Portrait</option>
                <option value="a4landscape">A4 Landscape</option>
                <option value="letterportrait">Letter Portrait</option>
                <option value="letterlandscape">Letter Landscape</option>
            </select>
        </div>

        <div class="control-group">
            <label>Background Color</label>
            <input type="color" id="bgColor" value="#f0f0f0">
        </div>

        <div class="control-group">
            <label>Stroke Color</label>
            <input type="color" id="strokeColor" value="#000000">
        </div>
      <div class="control">
        <button id="randomizeAll" class="ts-btn">ðŸŽ¨ Randomize Colors</button>
      </div>

        <div class="control-group">
            <label>Surface Type:</label>
            <select id="surfaceType">
                <option value="klein">Klein Bottle</option>
                <option value="mobius">MÃ¶bius Strip</option>
                <option value="torus">Torus</option>
                <option value="sphere">Sphere</option>
                <option value="boy">Boy's Surface</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Projection Type:</label>
            <select id="projectionType">
                <option value="orthographic">Orthographic</option>
                <option value="perspective">Perspective</option>
                <option value="stereographic">Stereographic</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Resolution: <span id="resolutionValue" class="value-display">30</span></label>
            <input type="range" id="resolution" min="10" max="100" value="30" step="5">
        </div>
        
        <div class="control-group">
            <label>Scale: <span id="scaleValue" class="value-display">100</span></label>
            <input type="range" id="scale" min="50" max="300" value="100" step="10">
        </div>
        
        <div class="control-group">
            <label>Rotation X: <span id="rotXValue" class="value-display">0</span>Â°</label>
            <input type="range" id="rotX" min="0" max="360" value="0" step="5">
        </div>
        
        <div class="control-group">
            <label>Rotation Y: <span id="rotYValue" class="value-display">0</span>Â°</label>
            <input type="range" id="rotY" min="0" max="360" value="0" step="5">
        </div>
        
        <div class="control-group">
            <label>Rotation Z: <span id="rotZValue" class="value-display">0</span>Â°</label>
            <input type="range" id="rotZ" min="0" max="360" value="0" step="5">
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="hiddenLines" checked> Hidden Line Removal
            </label>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="autoRotate"> Auto Rotate
            </label>
        </div>
        
        <button onclick="exportSVG()">Export SVG</button>
        <button onclick="generateNew()">Generate New</button>
    </div>

    <script>
        let surface = [];
        let projectedPoints = [];
        let edges = [];
        let params = {
            paperSize: 'square800',
            bgColor: '#f0f0f0',
            strokeColor: '#000000',
            surfaceType: 'klein',
            projectionType: 'orthographic',
            resolution: 30,
            scale: 100,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            hiddenLines: true,
            autoRotate: false
        };

    // Canvas controls for color randomization with WCAG AA contrast
    const canvasControls = new TSCanvasControls({
      bgColor: params.bgColor || '#ffffff',
      strokeColor: params.strokeColor || '#000000'
    });
    canvasControls.bind(params);
        
        let presetManager;

        function setup() {
            const size = CanvasLayout.getSize(params.paperSize);
            createCanvas(size.width, size.height);

            // Canvas settings handlers
            document.getElementById('paperSize').addEventListener('change', (e) => {
                params.paperSize = e.target.value;
                resizeCanvasForPaperSize();
            });
            document.getElementById('bgColor').addEventListener('input', (e) => {
                params.bgColor = e.target.value;
            });
            document.getElementById('strokeColor').addEventListener('input', (e) => {
                params.strokeColor = e.target.value;
            });

            setupControls();
      canvasControls.setupRandomizeButton();

            // Initialize preset manager
            presetManager = new PresetManager({
                algorithmId: 'parametric-surfaces',
                container: '#preset-container',
                onSave: () => params,
                onLoad: (preset) => {
                    Object.assign(params, preset.data);
                    updateUIFromParams();
                    generateSurface();
                },
                onRandomize: () => {
                    const types = ['klein', 'mobius', 'torus', 'sphere', 'boy'];
                    const projections = ['orthographic', 'perspective', 'stereographic'];
                    params.surfaceType = random(types);
                    params.projectionType = random(projections);
                    params.resolution = Math.floor(random(10, 100));
                    params.scale = Math.floor(random(50, 300));
                    params.rotX = Math.floor(random(0, 360));
                    params.rotY = Math.floor(random(0, 360));
                    params.rotZ = Math.floor(random(0, 360));
                    params.hiddenLines = random() > 0.5;
                    params.autoRotate = random() > 0.5;
                    updateUIFromParams();
                    generateSurface();
                }
            });

            generateSurface();
        }

        function updateUIFromParams() {
            document.getElementById('paperSize').value = params.paperSize;
            document.getElementById('bgColor').value = params.bgColor;
            document.getElementById('strokeColor').value = params.strokeColor;
            document.getElementById('surfaceType').value = params.surfaceType;
            document.getElementById('projectionType').value = params.projectionType;
            document.getElementById('resolution').value = params.resolution;
            document.getElementById('scale').value = params.scale;
            document.getElementById('rotX').value = params.rotX;
            document.getElementById('rotY').value = params.rotY;
            document.getElementById('rotZ').value = params.rotZ;
            document.getElementById('hiddenLines').checked = params.hiddenLines;
            document.getElementById('autoRotate').checked = params.autoRotate;

            document.getElementById('resolutionValue').textContent = params.resolution;
            document.getElementById('scaleValue').textContent = params.scale;
            document.getElementById('rotXValue').textContent = params.rotX;
            document.getElementById('rotYValue').textContent = params.rotY;
            document.getElementById('rotZValue').textContent = params.rotZ;
        }

        function resizeCanvasForPaperSize() {
            const size = CanvasLayout.getSize(params.paperSize);
            resizeCanvas(size.width, size.height);
            generateSurface();
        }

        function setupControls() {
            // Surface type
            document.getElementById('surfaceType').addEventListener('change', (e) => {
                params.surfaceType = e.target.value;
                generateSurface();
            });
            
            // Projection type
            document.getElementById('projectionType').addEventListener('change', (e) => {
                params.projectionType = e.target.value;
                projectSurface();
            });
            
            // Resolution
            document.getElementById('resolution').addEventListener('input', (e) => {
                params.resolution = parseInt(e.target.value);
                document.getElementById('resolutionValue').textContent = e.target.value;
                generateSurface();
            });
            
            // Scale
            document.getElementById('scale').addEventListener('input', (e) => {
                params.scale = parseInt(e.target.value);
                document.getElementById('scaleValue').textContent = e.target.value;
                projectSurface();
            });
            
            // Rotations
            ['rotX', 'rotY', 'rotZ'].forEach(axis => {
                document.getElementById(axis).addEventListener('input', (e) => {
                    params[axis] = parseInt(e.target.value);
                    document.getElementById(axis + 'Value').textContent = e.target.value;
                    projectSurface();
                });
            });
            
            // Hidden lines
            document.getElementById('hiddenLines').addEventListener('change', (e) => {
                params.hiddenLines = e.target.checked;
            });
            
            // Auto rotate
            document.getElementById('autoRotate').addEventListener('change', (e) => {
                params.autoRotate = e.target.checked;
            });
        }
        
        function generateSurface() {
            surface = [];
            edges = [];
            
            switch(params.surfaceType) {
                case 'klein':
                    generateKleinBottle();
                    break;
                case 'mobius':
                    generateMobiusStrip();
                    break;
                case 'torus':
                    generateTorus();
                    break;
                case 'sphere':
                    generateSphere();
                    break;
                case 'boy':
                    generateBoySurface();
                    break;
            }
            
            projectSurface();
        }
        
        function generateKleinBottle() {
            const res = params.resolution;
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const u = (i / res) * TWO_PI;
                    const v = (j / res) * TWO_PI;
                    
                    const r = 4 * (1 - cos(u) / 2);
                    let x, y, z;
                    
                    if (u < PI) {
                        x = 6 * cos(u) * (1 + sin(u)) + r * cos(v) * cos(u);
                        y = 16 * sin(u) + r * cos(v) * sin(u);
                        z = r * sin(v);
                    } else {
                        x = 6 * cos(u) * (1 + sin(u)) + r * cos(v + PI);
                        y = 16 * sin(u);
                        z = r * sin(v);
                    }
                    
                    surface.push(createVector(x, y, z));
                    
                    // Create edges
                    if (i < res - 1 && j < res - 1) {
                        const idx = i * res + j;
                        edges.push([idx, idx + 1]);
                        edges.push([idx, idx + res]);
                    }
                }
            }
        }
        
        function generateMobiusStrip() {
            const res = params.resolution;
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res / 2; j++) {
                    const s = (i / res) * TWO_PI;
                    const t = (j / (res / 2) - 0.5) * 2;
                    
                    const x = (1 + t * cos(s / 2)) * cos(s);
                    const y = (1 + t * cos(s / 2)) * sin(s);
                    const z = t * sin(s / 2);
                    
                    surface.push(createVector(x * 50, y * 50, z * 50));
                    
                    if (i < res - 1 && j < res / 2 - 1) {
                        const idx = i * (res / 2) + j;
                        edges.push([idx, idx + 1]);
                        edges.push([idx, idx + res / 2]);
                    }
                }
            }
        }
        
        function generateTorus() {
            const res = params.resolution;
            const R = 2; // Major radius
            const r = 1; // Minor radius
            
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const u = (i / res) * TWO_PI;
                    const v = (j / res) * TWO_PI;
                    
                    const x = (R + r * cos(v)) * cos(u);
                    const y = (R + r * cos(v)) * sin(u);
                    const z = r * sin(v);
                    
                    surface.push(createVector(x * 30, y * 30, z * 30));
                    
                    if (i < res - 1 && j < res - 1) {
                        const idx = i * res + j;
                        edges.push([idx, idx + 1]);
                        edges.push([idx, idx + res]);
                    }
                }
            }
        }
        
        function generateSphere() {
            const res = params.resolution;
            
            for (let i = 0; i <= res; i++) {
                for (let j = 0; j <= res; j++) {
                    const theta = (i / res) * PI;
                    const phi = (j / res) * TWO_PI;
                    
                    const x = sin(theta) * cos(phi);
                    const y = sin(theta) * sin(phi);
                    const z = cos(theta);
                    
                    surface.push(createVector(x * 100, y * 100, z * 100));
                    
                    if (i < res && j < res) {
                        const idx = i * (res + 1) + j;
                        edges.push([idx, idx + 1]);
                        edges.push([idx, idx + res + 1]);
                    }
                }
            }
        }
        
        function generateBoySurface() {
            const res = params.resolution;
            
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const u = (i / res) * PI;
                    const v = (j / res) * PI;
                    
                    const denom = sqrt(2) - sin(2 * u) * sin(3 * v);
                    const x = (sqrt(2) * cos(2 * u) * cos(v) * cos(v) + cos(u) * sin(2 * v)) / denom;
                    const y = (sqrt(2) * sin(2 * u) * cos(v) * cos(v) - sin(u) * sin(2 * v)) / denom;
                    const z = (3 * cos(v) * cos(v)) / denom;
                    
                    surface.push(createVector(x * 50, y * 50, z * 50));
                    
                    if (i < res - 1 && j < res - 1) {
                        const idx = i * res + j;
                        edges.push([idx, idx + 1]);
                        edges.push([idx, idx + res]);
                    }
                }
            }
        }
        
        function rotatePoint(p, angleX, angleY, angleZ) {
            let rotated = p.copy();
            
            // Rotate around X
            const cosX = cos(angleX);
            const sinX = sin(angleX);
            const y1 = rotated.y * cosX - rotated.z * sinX;
            const z1 = rotated.y * sinX + rotated.z * cosX;
            rotated.y = y1;
            rotated.z = z1;
            
            // Rotate around Y
            const cosY = cos(angleY);
            const sinY = sin(angleY);
            const x2 = rotated.x * cosY + rotated.z * sinY;
            const z2 = -rotated.x * sinY + rotated.z * cosY;
            rotated.x = x2;
            rotated.z = z2;
            
            // Rotate around Z
            const cosZ = cos(angleZ);
            const sinZ = sin(angleZ);
            const x3 = rotated.x * cosZ - rotated.y * sinZ;
            const y3 = rotated.x * sinZ + rotated.y * cosZ;
            rotated.x = x3;
            rotated.y = y3;
            
            return rotated;
        }
        
        function projectSurface() {
            projectedPoints = [];
            
            const angleX = radians(params.rotX);
            const angleY = radians(params.rotY);
            const angleZ = radians(params.rotZ);
            
            for (let p of surface) {
                const rotated = rotatePoint(p, angleX, angleY, angleZ);
                let projected;
                
                switch(params.projectionType) {
                    case 'orthographic':
                        projected = createVector(rotated.x, rotated.y);
                        break;
                    case 'perspective':
                        const d = 300; // Distance to projection plane
                        const scale = d / (d + rotated.z);
                        projected = createVector(rotated.x * scale, rotated.y * scale);
                        break;
                    case 'stereographic':
                        const r = 200; // Radius of projection sphere
                        const denom = r - rotated.z;
                        projected = createVector(
                            (rotated.x * r) / denom,
                            (rotated.y * r) / denom
                        );
                        break;
                }
                
                projectedPoints.push(projected.mult(params.scale / 100));
            }
        }
        
        function draw() {
            background(params.bgColor);
            translate(width / 2, height / 2);

            if (params.autoRotate) {
                params.rotY = (params.rotY + 1) % 360;
                document.getElementById('rotY').value = params.rotY;
                document.getElementById('rotYValue').textContent = params.rotY;
                projectSurface();
            }

            stroke(params.strokeColor);
            strokeWeight(1);
            noFill();
            
            if (params.hiddenLines) {
                drawWithHiddenLineRemoval();
            } else {
                drawAllEdges();
            }
        }
        
        function drawAllEdges() {
            for (let edge of edges) {
                const p1 = projectedPoints[edge[0]];
                const p2 = projectedPoints[edge[1]];
                if (p1 && p2) {
                    line(p1.x, p1.y, p2.x, p2.y);
                }
            }
        }
        
        function drawWithHiddenLineRemoval() {
            // Simple hidden line removal based on normal direction
            const drawnEdges = new Set();
            
            for (let i = 0; i < edges.length; i++) {
                const edge = edges[i];
                const edgeKey = edge[0] + ',' + edge[1];
                
                if (drawnEdges.has(edgeKey)) continue;
                
                // Check if edge should be visible
                if (isEdgeVisible(edge)) {
                    const p1 = projectedPoints[edge[0]];
                    const p2 = projectedPoints[edge[1]];
                    if (p1 && p2) {
                        line(p1.x, p1.y, p2.x, p2.y);
                        drawnEdges.add(edgeKey);
                    }
                }
            }
        }
        
        function isEdgeVisible(edge) {
            // Simplified visibility check based on z-depth
            const p1 = surface[edge[0]];
            const p2 = surface[edge[1]];
            
            if (!p1 || !p2) return false;
            
            const angleX = radians(params.rotX);
            const angleY = radians(params.rotY);
            const angleZ = radians(params.rotZ);
            
            const r1 = rotatePoint(p1, angleX, angleY, angleZ);
            const r2 = rotatePoint(p2, angleX, angleY, angleZ);
            
            // Simple check: if both points are behind viewer, hide edge
            return r1.z > -100 || r2.z > -100;
        }
        
        function exportSVG() {
            const svg = createSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `parametric-${params.surfaceType}-${Date.now()}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function createSVG() {
            const padding = 50;
            const svgWidth = width;
            const svgHeight = height;

            let svg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<rect width="${svgWidth}" height="${svgHeight}" fill="${params.bgColor}"/>\n`;
            svg += `<g transform="translate(${svgWidth/2}, ${svgHeight/2})">\n`;

            for (let edge of edges) {
                if (!params.hiddenLines || isEdgeVisible(edge)) {
                    const p1 = projectedPoints[edge[0]];
                    const p2 = projectedPoints[edge[1]];
                    if (p1 && p2) {
                        svg += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${params.strokeColor}" stroke-width="1"/>\n`;
                    }
                }
            }
            
            svg += `</g>\n</svg>`;
            return svg;
        }
        
        function generateNew() {
            generateSurface();
        }
        
        function windowResized() {
            resizeCanvasForPaperSize();
        }
    </script>
</body>
</html>
