<!DOCTYPE html>
<html>
<head>
  <title>Spiral Dots & Radial Burst Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.5.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
  <script src="../../preset-manager.js"></script>
  <link rel="stylesheet" href="../../preset-manager.css">
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      background: #1a1a1a;
      color: #fff;
    }
    #canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #2a2a2a;
      position: sticky;
      top: 0;
      height: 100vh;
      overflow: hidden;
    }
    #controls {
      width: 320px;
      padding: 20px;
      background: #1a1a1a;
      height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    h2 {
      margin: 0 0 20px 0;
      color: #4CAF50;
    }
    .control-group {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #333;
    }
    .control-group h3 {
      margin: 0 0 15px 0;
      color: #4CAF50;
      font-size: 16px;
    }
    .control {
      margin-bottom: 12px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      color: #ccc;
    }
    input[type="range"] {
      width: 100%;
    }
    select {
      width: 100%;
      padding: 5px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }
    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      background: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
      border-radius: 4px;
    }
    button:hover {
      background: #45a049;
    }
    .value {
      font-weight: bold;
      color: #4CAF50;
    }
    #seed-display {
      font-family: monospace;
      background: #333;
      padding: 5px;
      border-radius: 4px;
      font-size: 12px;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
    }
    .checkbox-container input {
      margin-right: 10px;
    }
    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    .mode-button {
      padding: 10px;
      background: #333;
      border: 2px solid #555;
      color: #ccc;
      cursor: pointer;
      text-align: center;
      border-radius: 4px;
    }
    .mode-button.active {
      background: #4CAF50;
      border-color: #4CAF50;
      color: white;
    }
    .mode-button:hover:not(.active) {
      border-color: #777;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="controls">
    <h2>Spiral & Burst Generator</h2>
    
    <div class="control-group">
      <h3>Generator Mode</h3>
      <div class="mode-selector">
        <div class="mode-button active" id="mode-spiral" onclick="switchMode('spiral')">
          Spiral Dots
        </div>
        <div class="mode-button" id="mode-burst" onclick="switchMode('burst')">
          Radial Burst
        </div>
      </div>
    </div>

    <!-- Spiral Controls -->
    <div id="spiral-controls" class="mode-controls">
      <div class="control-group">
        <h3>Spiral Structure</h3>
        <div class="control">
          <label>Arms: <span class="value" id="numArms-val">30</span></label>
          <input type="range" id="numArms" min="3" max="100" value="30" step="1">
        </div>
        <div class="control">
          <label>Max Turns: <span class="value" id="maxTheta-val">5</span></label>
          <input type="range" id="maxTheta" min="1" max="15" value="5" step="0.5">
        </div>
        <div class="control">
          <label>Dots per Arm: <span class="value" id="dotsPerArm-val">250</span></label>
          <input type="range" id="dotsPerArm" min="50" max="500" value="250" step="10">
        </div>
        <div class="control">
          <label>Spiral Tightness: <span class="value" id="spiralTightness-val">0.017</span></label>
          <input type="range" id="spiralTightness" min="0.005" max="0.05" value="0.017" step="0.001">
        </div>
      </div>
      
      <div class="control-group">
        <h3>Spiral Placement</h3>
        <div class="control">
          <label>Center X: <span class="value" id="spiralCenterX-val">0.45</span></label>
          <input type="range" id="spiralCenterX" min="0.1" max="0.9" value="0.45" step="0.01">
        </div>
        <div class="control">
          <label>Center Y: <span class="value" id="spiralCenterY-val">0.55</span></label>
          <input type="range" id="spiralCenterY" min="0.1" max="0.9" value="0.55" step="0.01">
        </div>
        <div class="control">
          <label>Min Radius: <span class="value" id="minRadius-val">10</span>px</label>
          <input type="range" id="minRadius" min="5" max="100" value="10" step="5">
        </div>
        <div class="control">
          <label>Max Radius: <span class="value" id="maxRadius-val">420</span>px</label>
          <input type="range" id="maxRadius" min="200" max="600" value="420" step="10">
        </div>
        <div class="control">
          <label>Hole Radius: <span class="value" id="holeRadius-val">100</span>px</label>
          <input type="range" id="holeRadius" min="20" max="200" value="100" step="5">
        </div>
      </div>
      
      <div class="control-group">
        <h3>Spiral Appearance</h3>
        <div class="control">
          <label>Base Dot Size: <span class="value" id="baseDotSize-val">3</span></label>
          <input type="range" id="baseDotSize" min="1" max="10" value="3" step="0.5">
        </div>
        <div class="control">
          <label>Dot Size Growth: <span class="value" id="dotSizeGrowth-val">1.2</span></label>
          <input type="range" id="dotSizeGrowth" min="0.5" max="3.0" value="1.2" step="0.1">
        </div>
        <div class="control">
          <label>Arm Rotation: <span class="value" id="armRotationOffset-val">0</span>Â°</label>
          <input type="range" id="armRotationOffset" min="0" max="6.28" value="0" step="0.1">
        </div>
      </div>
    </div>

    <!-- Burst Controls -->
    <div id="burst-controls" class="mode-controls" style="display: none;">
      <div class="control-group">
        <h3>Burst Structure</h3>
        <div class="control">
          <label>Ray Count: <span class="value" id="numRays-val">1800</span></label>
          <input type="range" id="numRays" min="100" max="3000" value="1800" step="50">
        </div>
        <div class="control">
          <label>Min Ray Length: <span class="value" id="minRayLength-val">220</span>px</label>
          <input type="range" id="minRayLength" min="50" max="400" value="220" step="10">
        </div>
        <div class="control">
          <label>Max Ray Length: <span class="value" id="maxRayLength-val">420</span>px</label>
          <input type="range" id="maxRayLength" min="200" max="600" value="420" step="10">
        </div>
        <div class="control">
          <label>Angle Jitter: <span class="value" id="angleJitter-val">0.004</span></label>
          <input type="range" id="angleJitter" min="0" max="0.02" value="0.004" step="0.001">
        </div>
      </div>
      
      <div class="control-group">
        <h3>Burst Placement</h3>
        <div class="control">
          <label>Center X: <span class="value" id="burstCenterX-val">0.5</span></label>
          <input type="range" id="burstCenterX" min="0.1" max="0.9" value="0.5" step="0.01">
        </div>
        <div class="control">
          <label>Center Y: <span class="value" id="burstCenterY-val">0.5</span></label>
          <input type="range" id="burstCenterY" min="0.1" max="0.9" value="0.5" step="0.01">
        </div>
      </div>
      
      <div class="control-group">
        <h3>Noise & Variation</h3>
        <div class="control">
          <label>Noise Scale: <span class="value" id="noiseScale-val">0.8</span></label>
          <input type="range" id="noiseScale" min="0.1" max="2.0" value="0.8" step="0.1">
        </div>
        <div class="control">
          <label>Noise Strength: <span class="value" id="noiseStrength-val">150</span></label>
          <input type="range" id="noiseStrength" min="0" max="300" value="150" step="10">
        </div>
        <div class="control">
          <label>Stroke Base: <span class="value" id="strokeBase-val">1.3</span></label>
          <input type="range" id="strokeBase" min="0.5" max="5.0" value="1.3" step="0.1">
        </div>
        <div class="control">
          <label>Stroke Variation: <span class="value" id="strokeVariation-val">3</span></label>
          <input type="range" id="strokeVariation" min="0" max="8" value="3" step="0.5">
        </div>
      </div>
      
      <div class="control-group">
        <h3>Inner Effects</h3>
        <div class="control">
          <label>Fuzz Radius: <span class="value" id="innerFuzzRadius-val">120</span>px</label>
          <input type="range" id="innerFuzzRadius" min="50" max="300" value="120" step="10">
        </div>
        <div class="control">
          <label>Fuzz Chance: <span class="value" id="innerFuzzChance-val">0.55</span></label>
          <input type="range" id="innerFuzzChance" min="0" max="1" value="0.55" step="0.05">
        </div>
        <div class="control">
          <label>Segment Jitter: <span class="value" id="segmentJitter-val">5</span></label>
          <input type="range" id="segmentJitter" min="1" max="20" value="5" step="1">
        </div>
      </div>
    </div>
    
    <div class="control-group">
      <h3>Colors</h3>
      <div class="control">
        <label>Background:</label>
        <select id="bgColorMode">
          <option value="#f7f2e8">Cream (Spiral)</option>
          <option value="#f6d54a">Yellow (Burst)</option>
          <option value="#ffffff">White</option>
          <option value="#000000">Black</option>
          <option value="#f0f0f0">Light Gray</option>
        </select>
      </div>
      <div class="control">
        <label>Foreground:</label>
        <select id="fgColorMode">
          <option value="#222222">Dark Gray</option>
          <option value="#324c9e">Blue</option>
          <option value="#000000">Black</option>
          <option value="#ffffff">White</option>
          <option value="#ff0000">Red</option>
        </select>
      </div>
    </div>
    
    <div class="control-group">
      <h3>Generation</h3>
      <div class="control">
        <label>Seed: <span id="seed-display">12345</span></label>
      </div>
      <div class="control checkbox-container">
        <input type="checkbox" id="autoRegenerate" checked>
        <label for="autoRegenerate">Auto regenerate on change</label>
      </div>
      <button onclick="regenerate()">Regenerate</button>
      <button onclick="randomizeSeed()">Random Seed</button>
      <button onclick="randomizeParams()">Randomize Parameters</button>
      <button onclick="saveParams()">Save Parameters</button>
    </div>
    
    <div class="control-group">
      <h3>Export</h3>
      <button onclick="exportSVG()">Export SVG</button>
      <button onclick="exportPNG()">Export PNG</button>
      <button onclick="exportLayers()">Export as Layers</button>
      <button onclick="exportGIF()">Export Animated GIF</button>
      <div id="export-status" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
    </div>
  </div>

  <script>
    // Current mode: "spiral" or "burst"
    let currentMode = "spiral";

    // All parameters in one place
    const spiralParams = {
      canvasSize: 800,
      bgColor: "#f7f2e8",
      dotColor: "#222222",
      centerX: 0.45,
      centerY: 0.55,
      numArms: 30,
      maxTheta: 5,
      minRadius: 10,
      maxRadius: 420,
      baseDotSize: 3,
      dotSizeGrowth: 1.2,
      dotsPerArm: 250,
      spiralTightness: 0.017,
      armRotationOffset: 0,
      holeRadius: 100
    };

    const burstParams = {
      canvasSize: 800,
      bgColor: "#f6d54a",
      lineColorA: "#324c9e",
      lineColorB: "#f6d54a",
      centerX: 0.5,
      centerY: 0.5,
      minRayLength: 220,
      maxRayLength: 420,
      numRays: 1800,
      angleJitter: 0.004,
      noiseScale: 0.8,
      noiseStrength: 150,
      strokeBase: 1.3,
      strokeVariation: 3,
      innerFuzzRadius: 120,
      innerFuzzChance: 0.55,
      segmentJitter: 5
    };

    let params = { ...spiralParams };
    let seed = Math.floor(Math.random() * 1000000);
    let autoRegenerate = true;
    let regenTimer;
    const REGEN_DEBOUNCE = 150;
    let svgCanvas;

    function setup() {
      const size = params.canvasSize || 800;
      svgCanvas = createCanvas(size, size);
      svgCanvas.parent('canvas-container');
      pixelDensity(2);
      
      setupControls();
      updateSeedDisplay();
      regenerate();
      noLoop();
    }

    function draw() {
      if (currentMode === "spiral") {
        drawSpiralDots();
      } else {
        drawBurst();
      }
    }

    function switchMode(mode) {
      currentMode = mode;
      
      // Update UI
      document.getElementById('mode-spiral').classList.toggle('active', mode === 'spiral');
      document.getElementById('mode-burst').classList.toggle('active', mode === 'burst');
      document.getElementById('spiral-controls').style.display = mode === 'spiral' ? 'block' : 'none';
      document.getElementById('burst-controls').style.display = mode === 'burst' ? 'block' : 'none';
      
      // Update params
      if (mode === 'spiral') {
        params = { ...spiralParams };
      } else {
        params = { ...burstParams };
      }
      
      updateControlValues();
      regenerate();
    }

    function setupControls() {
      // Range inputs
      const ranges = ['numArms', 'maxTheta', 'dotsPerArm', 'spiralTightness', 'spiralCenterX', 'spiralCenterY',
                     'minRadius', 'maxRadius', 'holeRadius', 'baseDotSize', 'dotSizeGrowth', 'armRotationOffset',
                     'numRays', 'minRayLength', 'maxRayLength', 'angleJitter', 'burstCenterX', 'burstCenterY',
                     'noiseScale', 'noiseStrength', 'strokeBase', 'strokeVariation', 'innerFuzzRadius', 
                     'innerFuzzChance', 'segmentJitter'];

      ranges.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            
            // Map control names to param names
            let paramKey = id;
            if (id === 'spiralCenterX') paramKey = 'centerX';
            if (id === 'spiralCenterY') paramKey = 'centerY';
            if (id === 'burstCenterX') paramKey = 'centerX';
            if (id === 'burstCenterY') paramKey = 'centerY';
            
            params[paramKey] = value;
            
            const display = document.getElementById(id + '-val');
            if (display) display.textContent = value;
            
            queueRegenerate();
          });
        }
      });

      // Color selectors
      ['bgColorMode', 'fgColorMode'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('change', (e) => {
            if (id === 'bgColorMode') {
              if (currentMode === 'spiral') {
                params.bgColor = e.target.value;
              } else {
                params.bgColor = e.target.value;
              }
            } else {
              if (currentMode === 'spiral') {
                params.dotColor = e.target.value;
              } else {
                params.lineColorA = e.target.value;
              }
            }
            queueRegenerate();
          });
        }
      });

      // Auto regenerate toggle
      const autoToggle = document.getElementById('autoRegenerate');
      if (autoToggle) {
        autoToggle.addEventListener('change', (e) => {
          autoRegenerate = e.target.checked;
          if (autoRegenerate) queueRegenerate();
        });
      }
    }

    function updateControlValues() {
      // Update all control values and displays
      Object.entries(params).forEach(([key, value]) => {
        let controlId = key;
        if (key === 'centerX') controlId = currentMode === 'spiral' ? 'spiralCenterX' : 'burstCenterX';
        if (key === 'centerY') controlId = currentMode === 'spiral' ? 'spiralCenterY' : 'burstCenterY';
        
        const control = document.getElementById(controlId);
        const display = document.getElementById(controlId + '-val');
        
        if (control && control.type === 'range') {
          control.value = value;
          if (display) display.textContent = value;
        }
      });
    }

    function queueRegenerate() {
      if (!autoRegenerate) return;
      clearTimeout(regenTimer);
      regenTimer = setTimeout(regenerate, REGEN_DEBOUNCE);
    }

    function regenerate() {
      randomSeed(seed);
      redraw();
    }

    function randomizeSeed() {
      seed = Math.floor(Math.random() * 1000000);
      updateSeedDisplay();
      regenerate();
    }

    function randomizeParams() {
      if (currentMode === 'spiral') {
        randomizeSpiral();
      } else {
        randomizeBurst();
      }
      updateControlValues();
      regenerate();
    }

    function randomizeSpiral() {
      params.numArms = int(random(10, 60));
      params.maxTheta = random(3, 8);
      params.dotsPerArm = int(random(150, 400));
      params.spiralTightness = random(0.01, 0.03);
      params.holeRadius = random(60, 150);
      params.baseDotSize = random(2, 5);
      params.dotSizeGrowth = random(0.5, 2.0);
      params.armRotationOffset = random(TWO_PI);
    }

    function randomizeBurst() {
      params.numRays = int(random(800, 2600));
      params.minRayLength = random(150, 280);
      params.maxRayLength = random(320, 520);
      params.noiseScale = random(0.4, 1.6);
      params.noiseStrength = random(50, 220);
      params.strokeBase = random(0.5, 2.5);
      params.strokeVariation = random(1, 4);
      params.innerFuzzRadius = random(70, 180);
      params.innerFuzzChance = random(0.3, 0.8);
      params.segmentJitter = random(2, 10);
    }

    function updateSeedDisplay() {
      document.getElementById('seed-display').textContent = seed;
    }

    /* ----------------------------------------------------------
       SPIRAL DOT FIELD
    -------------------------------------------------------------*/

    function drawSpiralDots() {
      const p = params;
      background(p.bgColor);
      noStroke();
      fill(p.dotColor);

      const cx = p.centerX * width;
      const cy = p.centerY * height;

      // Draw each spiral arm as a parametric curve
      for (let arm = 0; arm < p.numArms; arm++) {
        const armPhase = map(arm, 0, p.numArms, 0, TWO_PI);
        for (let i = 0; i < p.dotsPerArm; i++) {
          const t = i / (p.dotsPerArm - 1); // 0..1
          const theta = t * p.maxTheta * TWO_PI + armPhase + p.armRotationOffset;

          // logarithmic style radius
          const baseR = lerp(p.minRadius, p.maxRadius, t);
          const r = baseR * exp(p.spiralTightness * t * p.maxTheta * TWO_PI);

          const x = cx + r * cos(theta);
          const y = cy + r * sin(theta);

          // skip dots that would overlap the central hole
          const dCenter = dist(x, y, cx, cy);
          if (dCenter < p.holeRadius) continue;

          // dot size grows slightly as we move outward
          const dotSize = p.baseDotSize * (1 + p.dotSizeGrowth * t);

          circle(x, y, dotSize);
        }
      }

      // Draw the central hole on top
      fill(p.bgColor);
      circle(cx, cy, p.holeRadius * 2);
    }

    /* ----------------------------------------------------------
       RADIAL BURST
    -------------------------------------------------------------*/

    function drawBurst() {
      const p = params;
      background(p.bgColor);
      strokeCap(SQUARE);
      noFill();

      const cx = p.centerX * width;
      const cy = p.centerY * height;

      // Use noise so rays have structure instead of pure randomness
      noiseDetail(3, 0.5);

      for (let i = 0; i < p.numRays; i++) {
        // base angle for the ray
        const baseAngle = map(i, 0, p.numRays, 0, TWO_PI);
        const angle = baseAngle + random(-p.angleJitter, p.angleJitter);

        // sample noise using direction so neighbors are related
        const nx = cos(baseAngle) * p.noiseScale;
        const ny = sin(baseAngle) * p.noiseScale;
        const n = noise(nx, ny);
        const noiseOffset = map(n, 0, 1, -p.noiseStrength, p.noiseStrength);

        // final ray length
        const rayLen = constrain(
          random(p.minRayLength, p.maxRayLength) + noiseOffset,
          p.minRayLength * 0.5,
          p.maxRayLength * 1.2
        );

        // small variation in stroke width
        const sw = p.strokeBase + random(p.strokeVariation);
        strokeWeight(sw);

        // alternate colors to get a dense colorful texture
        if (i % 3 === 0) stroke(p.lineColorA);
        else if (i % 5 === 0) stroke(p.lineColorB);
        else stroke(p.lineColorA + "AA"); // semi transparent

        const x2 = cx + rayLen * cos(angle);
        const y2 = cy + rayLen * sin(angle);

        // Some rays become fuzzy broken segments near the center
        const useFuzz = random() < p.innerFuzzChance;

        if (!useFuzz) {
          line(cx, cy, x2, y2);
        } else {
          drawFuzzyRay(cx, cy, x2, y2, p.innerFuzzRadius, p.segmentJitter);
        }
      }
    }

    // Break a ray into small jittered segments to create a noisy core
    function drawFuzzyRay(x1, y1, x2, y2, innerRadius, jitter) {
      const totalDist = dist(x1, y1, x2, y2);
      const steps = int(totalDist / 8); // segment count

      let prevX = x1;
      let prevY = y1;

      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const x = lerp(x1, x2, t);
        const y = lerp(y1, y2, t);

        const d = dist(x1, y1, x, y);

        // only jitter inside the innerRadius
        let jx = 0;
        let jy = 0;
        if (d < innerRadius) {
          jx = random(-jitter, jitter);
          jy = random(-jitter, jitter);
        }

        line(prevX, prevY, x + jx, y + jy);
        prevX = x + jx;
        prevY = y + jy;
      }
    }

    /* ----------------------------------------------------------
       EXPORT FUNCTIONS
    -------------------------------------------------------------*/

    function saveParams() {
      const data = {
        mode: currentMode,
        params: params,
        seed: seed
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `spiral-burst-${currentMode}-${seed}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportSVG() {
      // Create SVG version
      let svgCanvas = createGraphics(width, height, SVG);
      
      // Reproduce the current drawing on SVG canvas
      if (currentMode === "spiral") {
        drawSpiralSVG(svgCanvas);
      } else {
        drawBurstSVG(svgCanvas);
      }
      
      save(svgCanvas, `spiral-burst-${currentMode}-${seed}.svg`);
      svgCanvas.remove();
    }

    function drawSpiralSVG(canvas) {
      const p = params;
      canvas.background(p.bgColor);
      canvas.noStroke();
      canvas.fill(p.dotColor);

      const cx = p.centerX * canvas.width;
      const cy = p.centerY * canvas.height;

      for (let arm = 0; arm < p.numArms; arm++) {
        const armPhase = map(arm, 0, p.numArms, 0, TWO_PI);
        for (let i = 0; i < p.dotsPerArm; i++) {
          const t = i / (p.dotsPerArm - 1);
          const theta = t * p.maxTheta * TWO_PI + armPhase + p.armRotationOffset;

          const baseR = lerp(p.minRadius, p.maxRadius, t);
          const r = baseR * exp(p.spiralTightness * t * p.maxTheta * TWO_PI);

          const x = cx + r * cos(theta);
          const y = cy + r * sin(theta);

          const dCenter = dist(x, y, cx, cy);
          if (dCenter < p.holeRadius) continue;

          const dotSize = p.baseDotSize * (1 + p.dotSizeGrowth * t);
          canvas.circle(x, y, dotSize);
        }
      }

      canvas.fill(p.bgColor);
      canvas.circle(cx, cy, p.holeRadius * 2);
    }

    function drawBurstSVG(canvas) {
      const p = params;
      canvas.background(p.bgColor);
      canvas.strokeCap(SQUARE);
      canvas.noFill();

      const cx = p.centerX * canvas.width;
      const cy = p.centerY * canvas.height;

      canvas.noiseDetail(3, 0.5);

      for (let i = 0; i < p.numRays; i++) {
        const baseAngle = map(i, 0, p.numRays, 0, TWO_PI);
        const angle = baseAngle + random(-p.angleJitter, p.angleJitter);

        const nx = cos(baseAngle) * p.noiseScale;
        const ny = sin(baseAngle) * p.noiseScale;
        const n = noise(nx, ny);
        const noiseOffset = map(n, 0, 1, -p.noiseStrength, p.noiseStrength);

        const rayLen = constrain(
          random(p.minRayLength, p.maxRayLength) + noiseOffset,
          p.minRayLength * 0.5,
          p.maxRayLength * 1.2
        );

        const sw = p.strokeBase + random(p.strokeVariation);
        canvas.strokeWeight(sw);

        if (i % 3 === 0) canvas.stroke(p.lineColorA);
        else if (i % 5 === 0) canvas.stroke(p.lineColorB);
        else canvas.stroke(p.lineColorA + "AA");

        const x2 = cx + rayLen * cos(angle);
        const y2 = cy + rayLen * sin(angle);

        canvas.line(cx, cy, x2, y2);
      }
    }

    function exportPNG() {
      save(`spiral-burst-${currentMode}-${seed}.png`);
    }

    function exportLayers() {
      updateExportStatus('Generating layers...');
      
      if (currentMode === 'spiral') {
        // Layer 1: Dots
        let dotsLayer = createGraphics(width, height, SVG);
        const p = params;
        dotsLayer.noStroke();
        dotsLayer.fill(p.dotColor);

        const cx = p.centerX * width;
        const cy = p.centerY * height;

        for (let arm = 0; arm < p.numArms; arm++) {
          const armPhase = map(arm, 0, p.numArms, 0, TWO_PI);
          for (let i = 0; i < p.dotsPerArm; i++) {
            const t = i / (p.dotsPerArm - 1);
            const theta = t * p.maxTheta * TWO_PI + armPhase + p.armRotationOffset;

            const baseR = lerp(p.minRadius, p.maxRadius, t);
            const r = baseR * exp(p.spiralTightness * t * p.maxTheta * TWO_PI);

            const x = cx + r * cos(theta);
            const y = cy + r * sin(theta);

            const dCenter = dist(x, y, cx, cy);
            if (dCenter < p.holeRadius) continue;

            const dotSize = p.baseDotSize * (1 + p.dotSizeGrowth * t);
            dotsLayer.circle(x, y, dotSize);
          }
        }

        save(dotsLayer, `spiral-layer-dots-${seed}.svg`);
        dotsLayer.remove();

        // Layer 2: Hole
        let holeLayer = createGraphics(width, height, SVG);
        holeLayer.fill(p.bgColor);
        holeLayer.circle(cx, cy, p.holeRadius * 2);
        save(holeLayer, `spiral-layer-hole-${seed}.svg`);
        holeLayer.remove();
      }
      
      updateExportStatus('Layers exported!');
      setTimeout(() => updateExportStatus(''), 2000);
    }

    function exportGIF() {
      updateExportStatus('Preparing GIF...');
      
      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: width,
        height: height,
        workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
      });

      const frames = 60;
      const originalRotation = params.armRotationOffset || 0;
      
      for (let frame = 0; frame < frames; frame++) {
        updateExportStatus(`Generating frame ${frame + 1}/${frames}`);
        
        if (currentMode === 'spiral') {
          params.armRotationOffset = originalRotation + (frame / frames) * TWO_PI;
        }
        
        clear();
        redraw();
        
        gif.addFrame(drawingContext.canvas, { copy: true, delay: 100 });
      }
      
      params.armRotationOffset = originalRotation;
      
      updateExportStatus('Rendering GIF...');
      
      gif.on('finished', function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `spiral-burst-${currentMode}-${seed}.gif`;
        a.click();
        URL.createObjectURL(url);
        
        updateExportStatus('GIF exported!');
        setTimeout(() => updateExportStatus(''), 3000);
      });

      gif.render();
    }

    function updateExportStatus(message) {
      document.getElementById('export-status').textContent = message;
    }

    // Keyboard shortcuts
    function keyPressed() {
      if (key === '1') {
        switchMode('spiral');
      } else if (key === '2') {
        switchMode('burst');
      } else if (key === 'R' || key === 'r') {
        randomizeSeed();
      } else if (key === 'S' || key === 's') {
        exportSVG();
      } else if (key === 'P' || key === 'p') {
        exportPNG();
      }
    }
  </script>
</body>
</html>