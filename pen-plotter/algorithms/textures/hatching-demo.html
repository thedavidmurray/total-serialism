<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <title>Hatching & Texture Library Demo - Updated</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.5.1"></script>
  <script src="../../canvas-layout.js"></script>
  <script src="../../preset-manager.js"></script>
  <script src="hatching-library.js"></script>
  <script src="../textures/ascii-art.js"></script>
  <script src="../../path-optimizer.js"></script>
  <script src="../../ui-utils.js"></script>
  <script src="../../export-utils.js"></script>
  <script src="../../plotter-optimizer.js"></script>

  <!-- Total Serialism Design System -->
  <link rel="stylesheet" href="../../shared/algorithm.css">
</head>
<body>
  <a href="../../index.html" class="back-link">Back to Index</a>

  <div id="canvas-container"></div>
  <div id="controls">
    <h2>ğŸ¨ Advanced Hatching Demo</h2>
    <p>Showcasing all new utility libraries working together</p>
    
    <div class="control-group">
      <h3>ğŸ”² Shape Configuration</h3>
    </div>
    
    <div class="control-group">
      <h3>ğŸ­ Pattern Configuration</h3>
    </div>
    
    <div class="control-group">
      <h3>âš™ï¸ Advanced Options</h3>
    </div>
    
    <div class="control-group">
      <h3>ğŸ® Presets</h3>
    </div>
    
    <div class="control-group">
      <h3>ğŸ’¾ Export</h3>
    </div>
  </div>

  <script>
    // Enhanced parameters using all utilities
    let params = {
      // Shape parameters
      shapeType: 'circle',
      shapeSize: 200,
      shapeX: 400,
      shapeY: 300,
      
      // Pattern parameters
      patternType: 'parallel',
      spacing: 5,
      angle: 45,
      density: 1.0,
      strokeWeight: 1.0,
      
      // Advanced options
      enableOptimization: true,
      showProgress: true,
      enableASCII: false,
      asciiCols: 60,
      
      // Animation
      animate: false,
      speed: 0.02
    };
    
    let canvas;
    let canvasLayout;
    let presetManager;
    let hatchingLib;
    let pathOpt;
    let optimizedPaths = [];
    let originalPaths = [];
    let currentShape = null;
    let animationTime = 0;
    let autoRegenerate = true;
    let regenTimer = null;
    
    function setup() {
      // Initialize canvas
      canvas = createCanvas(800, 600);
      canvas.parent('canvas-container');
      
      // Initialize all utility classes
      hatchingLib = new HatchingLibrary();
      pathOpt = new PathOptimizer();
      
      // Initialize preset manager
      presetManager = new PresetManager('hatching-demo', {
        defaultPresets: {
          'Wood Grain': {
            patternType: 'parallel',
            spacing: 3,
            angle: 15,
            density: 1.2,
            strokeWeight: 0.8
          },
          'Cross Hatch': {
            patternType: 'crosshatch',
            spacing: 4,
            angle: 45,
            density: 1.0,
            strokeWeight: 1.0
          },
          'Stipple Dense': {
            patternType: 'stipple',
            spacing: 2,
            density: 2.0,
            strokeWeight: 0.5
          },
          'Radial Burst': {
            patternType: 'radial',
            spacing: 6,
            angle: 0,
            density: 1.0,
            strokeWeight: 1.2
          },
          'Contour Lines': {
            patternType: 'contour',
            spacing: 8,
            angle: 0,
            density: 1.0,
            strokeWeight: 0.7
          }
        }
      });

      // Wire up preset events
      presetManager.onLoad = onPresetLoad;
      presetManager.onSave = onPresetSave;

      setupAdvancedUI();
      
      // Enable auto-regeneration with debouncing
      setupAutoRegenerate();
      
      // Initial generation
      generatePattern();
      
      uiUtils.showStatus('Hatching Demo Ready!', 'success', 2000);
    }
    
    function setupAdvancedUI() {
      const controls = document.getElementById('controls');
      
      // Shape controls using UI utils
      const shapeGroup = controls.querySelector('.control-group:nth-child(2)');
      
      uiUtils.createSelect(shapeGroup, 'Shape Type', 'shapeType', [
        { label: 'Circle', value: 'circle' },
        { label: 'Square', value: 'square' },
        { label: 'Triangle', value: 'triangle' },
        { label: 'Hexagon', value: 'hexagon' },
        { label: 'Star', value: 'star' },
        { label: 'Heart', value: 'heart' }
      ], params.shapeType);
      
      uiUtils.createSlider(shapeGroup, 'Shape Size', 'shapeSize', 50, 400, params.shapeSize);
      uiUtils.createSlider(shapeGroup, 'X Position', 'shapeX', 100, 700, params.shapeX);
      uiUtils.createSlider(shapeGroup, 'Y Position', 'shapeY', 100, 500, params.shapeY);
      
      // Pattern controls
      const patternGroup = controls.querySelector('.control-group:nth-child(3)');
      
      uiUtils.createSelect(patternGroup, 'Pattern Type', 'patternType', 
        hatchingLib.getAvailablePatterns().map(p => ({ label: p.charAt(0).toUpperCase() + p.slice(1), value: p })),
        params.patternType
      );
      
      uiUtils.createSlider(patternGroup, 'Spacing', 'spacing', 1, 20, params.spacing, 0.5);
      uiUtils.createSlider(patternGroup, 'Angle', 'angle', 0, 180, params.angle);
      uiUtils.createSlider(patternGroup, 'Density', 'density', 0.1, 3.0, params.density, 0.1);
      uiUtils.createSlider(patternGroup, 'Stroke Weight', 'strokeWeight', 0.1, 3.0, params.strokeWeight, 0.1);
      
      // Advanced options
      const advancedGroup = controls.querySelector('.control-group:nth-child(4)');
      
      uiUtils.createCheckbox(advancedGroup, 'Enable Path Optimization', 'enableOptimization', params.enableOptimization);
      uiUtils.createCheckbox(advancedGroup, 'Show Progress', 'showProgress', params.showProgress);
      uiUtils.createCheckbox(advancedGroup, 'ASCII Art Overlay', 'enableASCII', params.enableASCII);
      uiUtils.createSlider(advancedGroup, 'ASCII Columns', 'asciiCols', 20, 100, params.asciiCols);
      uiUtils.createCheckbox(advancedGroup, 'Animate', 'animate', params.animate);
      
      // Presets
      const presetGroup = controls.querySelector('.control-group:nth-child(5)');
      presetManager.createUI(presetGroup);
      
      // Export buttons using standardized export utils
      const exportGroup = controls.querySelector('.control-group:nth-child(6)');
      exportUtils.addExportButtons(exportGroup, drawForExport, 'hatching-demo', params);
      
      // Add optimization report button
      uiUtils.createButtonGroup(exportGroup, null, [
        {
          label: 'ğŸ“Š Optimization Report',
          callback: showOptimizationReport,
          style: { backgroundColor: '#FF9800' }
        },
        {
          label: 'ğŸ”„ Regenerate',
          callback: () => {
            generatePattern();
            uiUtils.showStatus('Pattern regenerated!', 'success', 1500);
          }
        }
      ]);
      
      // Attach change listeners
      attachChangeListeners();
    }
    
    function attachChangeListeners() {
      const paramKeys = Object.keys(params);
      
      paramKeys.forEach(key => {
        const element = document.getElementById(key);
        if (element) {
          const debouncedUpdate = uiUtils.debounce(() => {
            updateParams();
            if (autoRegenerate) {
              triggerRegenerate();
            }
          }, 150);
          
          element.addEventListener('input', debouncedUpdate);
          element.addEventListener('change', debouncedUpdate);
        }
      });
      
      // Special handling for animation toggle
      const animateElement = document.getElementById('animate');
      if (animateElement) {
        animateElement.addEventListener('change', (e) => {
          params.animate = e.target.checked;
          if (params.animate) {
            loop();
          } else {
            noLoop();
            redraw();
          }
        });
      }
    }
    
    function updateParams() {
      const paramKeys = Object.keys(params);
      const newValues = uiUtils.getParameterValues(paramKeys);
      Object.assign(params, newValues);
    }
    
    function setupAutoRegenerate() {
      // Auto-regenerate with debouncing
      function triggerRegenerate() {
        if (regenTimer) clearTimeout(regenTimer);
        regenTimer = setTimeout(() => {
          generatePattern();
        }, 200);
      }
      
      window.triggerRegenerate = triggerRegenerate;
    }
    
    function generatePattern() {
      if (params.showProgress) {
        uiUtils.showProgress(0, 4, 'Generating pattern...');
      }
      
      // Step 1: Create shape
      createShape();
      if (params.showProgress) uiUtils.showProgress(1, 4, 'Creating shape...');
      
      // Step 2: Generate hatching pattern
      generateHatchingPaths();
      if (params.showProgress) uiUtils.showProgress(2, 4, 'Generating hatching...');
      
      // Step 3: Optimize paths if enabled
      if (params.enableOptimization) {
        optimizePaths();
        if (params.showProgress) uiUtils.showProgress(3, 4, 'Optimizing paths...');
      }
      
      // Step 4: Complete
      if (params.showProgress) uiUtils.showProgress(4, 4, 'Complete!');
      
      if (!params.animate) {
        redraw();
      }
    }
    
    function createShape() {
      const centerX = params.shapeX;
      const centerY = params.shapeY;
      const size = params.shapeSize;
      
      switch (params.shapeType) {
        case 'circle':
          currentShape = {
            type: 'circle',
            x: centerX,
            y: centerY,
            diameter: size
          };
          break;
          
        case 'square':
          currentShape = {
            type: 'rect',
            x: centerX - size/2,
            y: centerY - size/2,
            width: size,
            height: size
          };
          break;
          
        case 'triangle':
          currentShape = createPolygonShape(centerX, centerY, size/2, 3);
          break;
          
        case 'hexagon':
          currentShape = createPolygonShape(centerX, centerY, size/2, 6);
          break;
          
        case 'star':
          currentShape = createStarShape(centerX, centerY, size/2, size/4, 5);
          break;
          
        case 'heart':
          currentShape = createHeartShape(centerX, centerY, size/40);
          break;
      }
    }
    
    function createPolygonShape(centerX, centerY, radius, sides) {
      const points = [];
      for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * TWO_PI - PI/2;
        points.push({
          x: centerX + cos(angle) * radius,
          y: centerY + sin(angle) * radius
        });
      }
      return { type: 'polygon', points };
    }
    
    function createStarShape(centerX, centerY, outerRadius, innerRadius, points) {
      const vertices = [];
      for (let i = 0; i < points * 2; i++) {
        const angle = (i / (points * 2)) * TWO_PI - PI/2;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        vertices.push({
          x: centerX + cos(angle) * radius,
          y: centerY + sin(angle) * radius
        });
      }
      return { type: 'polygon', points: vertices };
    }
    
    function createHeartShape(centerX, centerY, scale) {
      const points = [];
      for (let t = 0; t <= TWO_PI; t += 0.1) {
        const x = 16 * pow(sin(t), 3);
        const y = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t));
        points.push({
          x: centerX + x * scale,
          y: centerY + y * scale
        });
      }
      return { type: 'polygon', points };
    }
    
    function generateHatchingPaths() {
      originalPaths = [];
      
      if (!currentShape) return;
      
      const options = {
        spacing: params.spacing,
        angle: params.angle + (params.animate ? animationTime * 20 : 0),
        density: params.density,
        strokeWeight: params.strokeWeight
      };
      
      // Generate paths based on shape type
      if (currentShape.type === 'circle') {
        // Use circular bounds for hatching
        const bounds = {
          x: currentShape.x - currentShape.diameter/2,
          y: currentShape.y - currentShape.diameter/2,
          width: currentShape.diameter,
          height: currentShape.diameter
        };
        
        const paths = hatchingLib.hatchRegion(
          canvas, bounds.x, bounds.y, bounds.width, bounds.height,
          params.patternType, options
        );
        
        originalPaths = paths || [];
        
      } else if (currentShape.type === 'rect') {
        const paths = hatchingLib.hatchRegion(
          canvas, currentShape.x, currentShape.y, currentShape.width, currentShape.height,
          params.patternType, options
        );
        
        originalPaths = paths || [];
        
      } else if (currentShape.type === 'polygon') {
        // For complex polygons, create a bounding box and clip
        const bounds = getPolygonBounds(currentShape.points);
        const paths = hatchingLib.hatchRegion(
          canvas, bounds.x, bounds.y, bounds.width, bounds.height,
          params.patternType, options
        );
        
        originalPaths = paths || [];
      }
    }
    
    function getPolygonBounds(points) {
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;
      
      points.forEach(p => {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      });
      
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    
    function optimizePaths() {
      if (originalPaths.length === 0) return;
      
      // Convert to path format for optimizer
      const pathsForOptimization = originalPaths.map(path => {
        if (path.start && path.end) {
          return [
            { x: path.start.x, y: path.start.y },
            { x: path.end.x, y: path.end.y }
          ];
        }
        return [];
      }).filter(path => path.length > 0);
      
      optimizedPaths = pathOpt.optimizeAllPaths(pathsForOptimization, {
        removeShortPaths: true,
        simplifyPaths: true,
        mergeEndpoints: true,
        optimizeOrder: true,
        minLength: 2.0
      });
    }
    
    function drawForExport(exportCanvas, mode = 'screen') {
      if (mode === 'plotter') {
        // Plotter-optimized drawing (stroke only, no backgrounds)
        exportCanvas.stroke(0);
        exportCanvas.strokeWeight(params.strokeWeight);
        exportCanvas.noFill();
        
        drawOptimizedPaths(exportCanvas);
      } else {
        // Screen drawing (with backgrounds, fills, etc.)
        exportCanvas.background(255);
        drawPattern(exportCanvas);
        
        if (params.enableASCII) {
          drawASCIIOverlay(exportCanvas);
        }
      }
    }
    
    function draw() {
      background(255);
      
      if (params.animate) {
        animationTime += params.speed;
        generateHatchingPaths();
        if (params.enableOptimization) {
          optimizePaths();
        }
      }
      
      drawPattern(canvas);
      
      if (params.enableASCII) {
        drawASCIIOverlay(canvas);
      }
      
      if (!params.animate) {
        noLoop();
      }
    }
    
    function drawPattern(drawCanvas) {
      drawCanvas.push();
      
      // Draw shape outline
      drawCanvas.stroke(100);
      drawCanvas.strokeWeight(1);
      drawCanvas.noFill();
      
      if (currentShape) {
        if (currentShape.type === 'circle') {
          drawCanvas.circle(currentShape.x, currentShape.y, currentShape.diameter);
        } else if (currentShape.type === 'rect') {
          drawCanvas.rect(currentShape.x, currentShape.y, currentShape.width, currentShape.height);
        } else if (currentShape.type === 'polygon') {
          drawCanvas.beginShape();
          currentShape.points.forEach(p => drawCanvas.vertex(p.x, p.y));
          drawCanvas.endShape(CLOSE);
        }
      }
      
      // Draw pattern
      drawCanvas.stroke(0);
      drawCanvas.strokeWeight(params.strokeWeight);
      
      if (params.enableOptimization && optimizedPaths.length > 0) {
        drawOptimizedPaths(drawCanvas);
      } else {
        drawOriginalPaths(drawCanvas);
      }
      
      drawCanvas.pop();
    }
    
    function drawOptimizedPaths(drawCanvas) {
      optimizedPaths.forEach(path => {
        if (path.length >= 2) {
          drawCanvas.beginShape();
          drawCanvas.noFill();
          path.forEach(point => drawCanvas.vertex(point.x, point.y));
          drawCanvas.endShape();
        }
      });
    }
    
    function drawOriginalPaths(drawCanvas) {
      originalPaths.forEach(element => {
        if (element.type === 'line' && element.start && element.end) {
          drawCanvas.line(element.start.x, element.start.y, element.end.x, element.end.y);
        } else if (element.type === 'circle') {
          drawCanvas.circle(element.x, element.y, element.radius * 2);
        }
      });
    }
    
    function drawASCIIOverlay(drawCanvas) {
      // Create ASCII art overlay
      const tempGraphics = createGraphics(width, height);
      tempGraphics.background(255);
      drawPattern(tempGraphics);
      
      const asciiText = asciiArt.imageToASCII(tempGraphics, params.asciiCols, {
        characterSet: 'simple',
        invert: true,
        contrast: 1.2
      });
      
      drawCanvas.push();
      drawCanvas.fill(0, 100);
      drawCanvas.textFont('monospace');
      drawCanvas.textSize(8);
      drawCanvas.text(asciiText, 10, 20);
      drawCanvas.pop();
      
      tempGraphics.remove();
    }
    
    function showOptimizationReport() {
      if (originalPaths.length === 0 && optimizedPaths.length === 0) {
        uiUtils.showStatus('Generate a pattern first!', 'warning', 2000);
        return;
      }
      
      const report = pathOpt.generateReport(
        originalPaths.map(p => p.start && p.end ? [p.start, p.end] : []).filter(p => p.length > 0),
        optimizedPaths
      );
      
      const reportText = `
Path Optimization Report:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š Path Count:
   Original: ${report.originalPathCount}
   Optimized: ${report.optimizedPathCount}
   Reduction: ${report.pathReduction}%

ğŸ“ Drawing Length:
   Original: ${report.originalDrawingLength.toFixed(1)}mm
   Optimized: ${report.optimizedDrawingLength.toFixed(1)}mm
   Savings: ${report.lengthReduction}%

âœˆï¸ Pen Travel:
   Pen-up distance: ${report.penUpDistance.toFixed(1)}mm
   Total plotting: ${report.totalPlottingDistance.toFixed(1)}mm

ğŸ’¡ Efficiency gained through TSP optimization,
   path merging, and Douglas-Peucker simplification.
      `.trim();
      
      alert(reportText);
      
      console.log('Detailed Optimization Report:', report);
    }
    
    // Preset system integration
    function onPresetLoad(presetData) {
      Object.assign(params, presetData);
      uiUtils.updateParameterDisplays(params);
      generatePattern();
      uiUtils.showStatus(`Preset "${presetData.name}" loaded!`, 'success', 2000);
    }
    
    function onPresetSave(presetName) {
      uiUtils.showStatus(`Preset "${presetName}" saved!`, 'success', 2000);
    }
    
    // Wire up preset events - done in setup() after presetManager is created
  </script>
</body>
</html>