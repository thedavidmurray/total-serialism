<!DOCTYPE html>
<html>
<head>
  <title>Plotter Prep - Layer Splitting & Path Optimization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.5.1"></script>
  <script src="../../../../path-optimizer.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: white;
      margin-bottom: 10px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .main-content {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 20px;
      align-items: start;
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
    }

    .panel h3 {
      margin-bottom: 16px;
      color: #333;
      font-size: 1.1em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }

    .upload-area {
      border: 3px dashed #667eea;
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 20px;
      background: #f8f9fa;
    }

    .upload-area:hover {
      background: #e3f2fd;
      border-color: #764ba2;
    }

    .upload-area.dragover {
      background: #bbdefb;
      border-color: #1565c0;
    }

    .upload-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }

    .upload-text {
      color: #666;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .upload-hint {
      color: #999;
      font-size: 12px;
    }

    input[type="file"] {
      display: none;
    }

    button {
      width: 100%;
      padding: 12px;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    button.secondary {
      background: #6c757d;
    }

    button.secondary:hover:not(:disabled) {
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
    }

    button.small {
      padding: 6px 12px;
      font-size: 0.85em;
      width: auto;
      margin: 0;
    }

    .layers-list {
      margin-top: 16px;
      max-height: 300px;
      overflow-y: auto;
    }

    .layer-item {
      background: #f8f9fa;
      padding: 12px;
      margin-bottom: 8px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background 0.2s;
    }

    .layer-item:hover {
      background: #e9ecef;
    }

    .layer-item.optimized {
      border: 2px solid #28a745;
      background: #d4edda;
    }

    .layer-color {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 2px solid #ddd;
      flex-shrink: 0;
      cursor: pointer;
      position: relative;
    }

    .layer-color:hover::after {
      content: 'üé®';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
    }

    .layer-info {
      flex: 1;
      min-width: 0;
    }

    .layer-name {
      font-weight: 600;
      color: #333;
      font-size: 0.9em;
      cursor: text;
      padding: 2px 4px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .layer-name:hover {
      background: rgba(102, 126, 234, 0.1);
    }

    .layer-name-input {
      font-weight: 600;
      color: #333;
      font-size: 0.9em;
      padding: 2px 4px;
      border: 2px solid #667eea;
      border-radius: 4px;
      width: 100%;
      outline: none;
    }

    .layer-stats {
      font-size: 0.75em;
      color: #666;
      margin-top: 4px;
    }

    .layer-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .layer-actions {
      display: flex;
      gap: 4px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 16px;
    }

    .stat-box {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-box.optimized {
      background: #d4edda;
      border: 2px solid #28a745;
    }

    .stat-label {
      font-size: 0.75em;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: 600;
      color: #667eea;
      margin-top: 4px;
    }

    .stat-value.improved {
      color: #28a745;
    }

    .stat-comparison {
      font-size: 0.7em;
      color: #28a745;
      margin-top: 2px;
    }

    .canvas-panel {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 600px;
    }

    .preview-placeholder {
      text-align: center;
      color: #999;
    }

    .preview-placeholder-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      gap: 8px;
    }

    .checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .checkbox-group label {
      cursor: pointer;
      user-select: none;
      flex: 1;
    }

    .section {
      margin-bottom: 24px;
      padding-bottom: 24px;
      border-bottom: 1px solid #e9ecef;
    }

    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .status-message {
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 16px;
      font-size: 0.9em;
      text-align: center;
      display: none;
    }

    .status-message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status-message.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status-message.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .batch-files {
      margin-top: 12px;
      max-height: 150px;
      overflow-y: auto;
    }

    .batch-file-item {
      background: #f8f9fa;
      padding: 8px;
      margin-bottom: 6px;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85em;
    }

    .batch-file-item.processing {
      background: #d1ecf1;
    }

    .batch-file-item.completed {
      background: #d4edda;
    }

    .merge-controls {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e9ecef;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üõ†Ô∏è Plotter Prep</h1>
    <p class="subtitle">Upload SVG files to split layers, optimize paths, and prepare for plotting</p>

    <div class="main-content">
      <!-- Controls Panel -->
      <div class="panel">
        <div id="status-message" class="status-message"></div>

        <!-- Upload Section -->
        <div class="section">
          <h3>üìÅ Upload SVG</h3>
          <div id="upload-area" class="upload-area">
            <div class="upload-icon">üìÑ</div>
            <div class="upload-text">Drop SVG file(s) here or click to browse</div>
            <div class="upload-hint">Supports single or multiple files</div>
            <input type="file" id="file-input" accept=".svg,image/svg+xml" multiple>
          </div>
          <div id="batch-files" class="batch-files" style="display: none;"></div>
        </div>

        <!-- Layers Section -->
        <div class="section">
          <h3>üé® Layers</h3>
          <div id="layers-list" class="layers-list"></div>
          <div class="merge-controls" id="merge-controls" style="display: none;">
            <button class="secondary" onclick="mergeSelectedLayers()">Merge Selected Layers</button>
          </div>
        </div>

        <!-- Optimization Options -->
        <div class="section">
          <h3>‚öôÔ∏è Optimization</h3>
          <div class="checkbox-group">
            <input type="checkbox" id="opt-merge" checked>
            <label for="opt-merge">Merge connected paths</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="opt-sort" checked>
            <label for="opt-sort">Sort paths (TSP)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="opt-reloop" checked>
            <label for="opt-reloop">Reloop (prevent ink blots)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="opt-simplify" checked>
            <label for="opt-simplify">Simplify paths</label>
          </div>
        </div>

        <!-- Stats -->
        <div class="section">
          <h3>üìä Statistics</h3>
          <div class="stats-grid">
            <div class="stat-box" id="stat-box-paths">
              <div class="stat-label">Paths</div>
              <div class="stat-value" id="stat-paths">-</div>
              <div class="stat-comparison" id="stat-paths-comp"></div>
            </div>
            <div class="stat-box" id="stat-box-points">
              <div class="stat-label">Points</div>
              <div class="stat-value" id="stat-points">-</div>
              <div class="stat-comparison" id="stat-points-comp"></div>
            </div>
            <div class="stat-box" id="stat-box-travel">
              <div class="stat-label">Travel (mm)</div>
              <div class="stat-value" id="stat-travel">-</div>
              <div class="stat-comparison" id="stat-travel-comp"></div>
            </div>
            <div class="stat-box" id="stat-box-time">
              <div class="stat-label">Time Saved</div>
              <div class="stat-value" id="stat-time">-</div>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div class="section">
          <h3>üíæ Export</h3>
          <button id="btn-optimize" disabled>Optimize Selected Layers</button>
          <button id="btn-export-svg" class="secondary" disabled>Export Combined SVG</button>
          <button id="btn-export-layers" class="secondary" disabled>Export Separate Layers</button>
          <button id="btn-reset" class="secondary" disabled>Reset to Original</button>
        </div>
      </div>

      <!-- Canvas Panel -->
      <div class="canvas-panel" id="canvas-panel">
        <div class="preview-placeholder">
          <div class="preview-placeholder-icon">üé®</div>
          <div>Upload an SVG file to begin</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let svgData = null;
    let originalSvgData = null;
    let layers = [];
    let optimizer = new PathOptimizer();
    let canvas;
    let batchFiles = [];
    let optimizationStats = null;

    // Setup file upload
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');

    uploadArea.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFileUpload(e.target.files);
      }
    });

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');

      if (e.dataTransfer.files.length > 0) {
        handleFileUpload(e.dataTransfer.files);
      }
    });

    function handleFileUpload(files) {
      const svgFiles = Array.from(files).filter(f =>
        f.type.match('svg.*') || f.name.endsWith('.svg')
      );

      if (svgFiles.length === 0) {
        showStatus('Please upload SVG file(s)', 'error');
        return;
      }

      if (svgFiles.length === 1) {
        // Single file mode
        loadSVGFile(svgFiles[0]);
      } else {
        // Batch mode
        loadBatchFiles(svgFiles);
      }
    }

    function loadSVGFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        parseSVG(e.target.result, file.name);
      };
      reader.readAsText(file);
    }

    function loadBatchFiles(files) {
      batchFiles = files.map((file, index) => ({
        id: index,
        file: file,
        status: 'pending'
      }));

      renderBatchFiles();
      document.getElementById('batch-files').style.display = 'block';

      // Process first file
      processBatchFile(0);
    }

    function processBatchFile(index) {
      if (index >= batchFiles.length) {
        showStatus('All files processed!', 'success');
        return;
      }

      const batchFile = batchFiles[index];
      batchFile.status = 'processing';
      renderBatchFiles();

      const reader = new FileReader();
      reader.onload = (e) => {
        parseSVG(e.target.result, batchFile.file.name);
        batchFile.status = 'completed';
        renderBatchFiles();

        // Auto-export or move to next
        setTimeout(() => processBatchFile(index + 1), 500);
      };
      reader.readAsText(batchFile.file);
    }

    function renderBatchFiles() {
      const container = document.getElementById('batch-files');
      container.innerHTML = batchFiles.map(bf => `
        <div class="batch-file-item ${bf.status}">
          <span>${bf.file.name}</span>
          <span>${bf.status === 'completed' ? '‚úì' : bf.status === 'processing' ? '‚è≥' : '‚óã'}</span>
        </div>
      `).join('');
    }

    function parseSVG(svgText, filename = 'upload') {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, 'image/svg+xml');
      const svg = doc.documentElement;

      if (svg.tagName !== 'svg') {
        showStatus('Invalid SVG file', 'error');
        return;
      }

      svgData = svgText;
      originalSvgData = svgText;
      layers = [];
      optimizationStats = null;

      // Extract layers by color/stroke
      const pathElements = svg.querySelectorAll('path, line, polyline, polygon, rect, circle, ellipse');
      const colorMap = new Map();

      pathElements.forEach(el => {
        const stroke = el.getAttribute('stroke') || el.style.stroke || '#000000';
        const fill = el.getAttribute('fill') || el.style.fill || 'none';
        const color = stroke !== 'none' ? stroke : fill;

        if (!colorMap.has(color)) {
          colorMap.set(color, []);
        }
        colorMap.get(color).push(el);
      });

      // Create layers from colors
      let layerIndex = 0;
      colorMap.forEach((elements, color) => {
        const paths = extractPathsFromElements(elements);
        layers.push({
          id: layerIndex++,
          color: color,
          name: `Layer ${layerIndex}`,
          elements: elements,
          paths: paths,
          pathCount: paths.length,
          pointCount: paths.reduce((sum, p) => sum + p.points.length, 0),
          enabled: true,
          optimized: false,
          optimizedPaths: null
        });
      });

      renderLayers();
      renderPreview();
      updateStats();
      showStatus(`Loaded ${layers.length} layers with ${pathElements.length} paths`, 'success');

      // Enable buttons
      document.getElementById('btn-optimize').disabled = false;
      document.getElementById('btn-export-svg').disabled = false;
      document.getElementById('btn-export-layers').disabled = false;
      document.getElementById('btn-reset').disabled = false;
      document.getElementById('merge-controls').style.display = layers.length > 1 ? 'block' : 'none';
    }

    function extractPathsFromElements(elements) {
      const paths = [];

      elements.forEach(el => {
        const tagName = el.tagName.toLowerCase();
        let pathData = [];

        if (tagName === 'path') {
          // Parse path d attribute
          const d = el.getAttribute('d');
          pathData = parsePathD(d);
        } else if (tagName === 'line') {
          pathData = [
            { x: parseFloat(el.getAttribute('x1')), y: parseFloat(el.getAttribute('y1')) },
            { x: parseFloat(el.getAttribute('x2')), y: parseFloat(el.getAttribute('y2')) }
          ];
        } else if (tagName === 'polyline' || tagName === 'polygon') {
          const points = el.getAttribute('points').trim().split(/\s+/);
          pathData = points.map(p => {
            const [x, y] = p.split(',').map(parseFloat);
            return { x, y };
          });
        } else if (tagName === 'rect') {
          const x = parseFloat(el.getAttribute('x') || 0);
          const y = parseFloat(el.getAttribute('y') || 0);
          const w = parseFloat(el.getAttribute('width'));
          const h = parseFloat(el.getAttribute('height'));
          pathData = [
            { x, y },
            { x: x + w, y },
            { x: x + w, y: y + h },
            { x, y: y + h },
            { x, y }
          ];
        } else if (tagName === 'circle') {
          const cx = parseFloat(el.getAttribute('cx'));
          const cy = parseFloat(el.getAttribute('cy'));
          const r = parseFloat(el.getAttribute('r'));
          // Approximate circle with points
          for (let i = 0; i <= 36; i++) {
            const angle = (i / 36) * Math.PI * 2;
            pathData.push({
              x: cx + r * Math.cos(angle),
              y: cy + r * Math.sin(angle)
            });
          }
        }

        if (pathData.length > 0) {
          paths.push({
            points: pathData,
            closed: tagName === 'polygon' || tagName === 'circle' || tagName === 'rect'
          });
        }
      });

      return paths;
    }

    function parsePathD(d) {
      // Simple path parser - handles M, L, H, V, Z commands
      const points = [];
      const commands = d.match(/[MLHVZ][^MLHVZ]*/gi);
      let currentX = 0, currentY = 0;

      commands?.forEach(cmd => {
        const type = cmd[0];
        const values = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat);

        switch (type.toUpperCase()) {
          case 'M':
            currentX = values[0];
            currentY = values[1];
            points.push({ x: currentX, y: currentY });
            break;
          case 'L':
            currentX = values[0];
            currentY = values[1];
            points.push({ x: currentX, y: currentY });
            break;
          case 'H':
            currentX = values[0];
            points.push({ x: currentX, y: currentY });
            break;
          case 'V':
            currentY = values[0];
            points.push({ x: currentX, y: currentY });
            break;
        }
      });

      return points;
    }

    function renderLayers() {
      const layersList = document.getElementById('layers-list');

      if (layers.length === 0) {
        layersList.innerHTML = '<p style="color: #999; text-align: center;">No layers loaded</p>';
        return;
      }

      layersList.innerHTML = layers.map(layer => `
        <div class="layer-item ${layer.optimized ? 'optimized' : ''}">
          <input type="checkbox" class="layer-checkbox"
                 data-layer-id="${layer.id}"
                 ${layer.enabled ? 'checked' : ''}
                 onchange="toggleLayer(${layer.id})">
          <div class="layer-color" style="background: ${layer.color}"
               onclick="changeLayerColor(${layer.id})"
               title="Click to change color"></div>
          <div class="layer-info">
            <div class="layer-name" id="layer-name-${layer.id}"
                 onclick="editLayerName(${layer.id})">${layer.name}</div>
            <div class="layer-stats">
              ${layer.pathCount} paths ‚Ä¢ ${layer.pointCount} points
              ${layer.optimized ? ' ‚Ä¢ ‚úì Optimized' : ''}
            </div>
          </div>
        </div>
      `).join('');
    }

    function toggleLayer(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.enabled = !layer.enabled;
        renderPreview();
        updateStats();
      }
    }

    function editLayerName(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (!layer) return;

      const nameEl = document.getElementById(`layer-name-${layerId}`);
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'layer-name-input';
      input.value = layer.name;

      input.onblur = () => {
        layer.name = input.value || `Layer ${layerId + 1}`;
        renderLayers();
      };

      input.onkeydown = (e) => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') {
          input.value = layer.name;
          input.blur();
        }
      };

      nameEl.replaceWith(input);
      input.focus();
      input.select();
    }

    function changeLayerColor(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (!layer) return;

      const newColor = prompt('Enter new color (hex):', layer.color);
      if (newColor) {
        layer.color = newColor;
        renderLayers();
        renderPreview();
      }
    }

    function mergeSelectedLayers() {
      const selectedLayers = layers.filter(l => l.enabled);
      if (selectedLayers.length < 2) {
        showStatus('Select at least 2 layers to merge', 'error');
        return;
      }

      const mergedPaths = [];
      const mergedElements = [];
      let totalPoints = 0;

      selectedLayers.forEach(layer => {
        mergedPaths.push(...layer.paths);
        mergedElements.push(...layer.elements);
        totalPoints += layer.pointCount;
      });

      // Remove selected layers
      layers = layers.filter(l => !l.enabled);

      // Add merged layer
      layers.push({
        id: layers.length,
        color: selectedLayers[0].color,
        name: `Merged (${selectedLayers.length} layers)`,
        elements: mergedElements,
        paths: mergedPaths,
        pathCount: mergedPaths.length,
        pointCount: totalPoints,
        enabled: true,
        optimized: false,
        optimizedPaths: null
      });

      renderLayers();
      renderPreview();
      updateStats();
      showStatus(`Merged ${selectedLayers.length} layers`, 'success');
    }

    function renderPreview() {
      const canvasPanel = document.getElementById('canvas-panel');

      if (!svgData || layers.length === 0) {
        canvasPanel.innerHTML = `
          <div class="preview-placeholder">
            <div class="preview-placeholder-icon">üé®</div>
            <div>Upload an SVG file to begin</div>
          </div>
        `;
        return;
      }

      const enabledLayers = layers.filter(l => l.enabled);
      canvasPanel.innerHTML = `<div style="max-width: 100%; max-height: 100%; overflow: auto;">
        <p style="text-align: center; color: #666; margin-bottom: 10px;">
          Preview (${enabledLayers.length} layers enabled)
          ${optimizationStats ? ' ‚Ä¢ Optimized' : ''}
        </p>
        <div style="background: white; border: 1px solid #ddd; padding: 10px; border-radius: 8px;">
          ${svgData}
        </div>
      </div>`;
    }

    function updateStats() {
      const enabledLayers = layers.filter(l => l.enabled);
      const totalPaths = enabledLayers.reduce((sum, l) => sum + l.pathCount, 0);
      const totalPoints = enabledLayers.reduce((sum, l) => sum + l.pointCount, 0);

      document.getElementById('stat-paths').textContent = totalPaths;
      document.getElementById('stat-points').textContent = totalPoints;

      if (optimizationStats) {
        const travelReduction = ((1 - optimizationStats.optimizedTravelDistance / optimizationStats.originalTravelDistance) * 100).toFixed(1);
        const timeSaved = (optimizationStats.timeSaved / 60).toFixed(1);

        document.getElementById('stat-travel').textContent = optimizationStats.optimizedTravelDistance.toFixed(1);
        document.getElementById('stat-travel-comp').textContent = `‚Üì ${travelReduction}%`;
        document.getElementById('stat-time').textContent = `${timeSaved}m`;

        document.getElementById('stat-paths').textContent = optimizationStats.optimizedPaths;
        document.getElementById('stat-paths-comp').textContent = `(was ${optimizationStats.originalPaths})`;

        document.getElementById('stat-points').textContent = optimizationStats.optimizedPoints;
        document.getElementById('stat-points-comp').textContent = `(was ${optimizationStats.originalPoints})`;

        // Highlight optimized stats
        document.getElementById('stat-box-paths').classList.add('optimized');
        document.getElementById('stat-box-points').classList.add('optimized');
        document.getElementById('stat-box-travel').classList.add('optimized');
        document.getElementById('stat-box-time').classList.add('optimized');
      } else {
        document.getElementById('stat-travel').textContent = '-';
        document.getElementById('stat-time').textContent = '-';
        document.getElementById('stat-paths-comp').textContent = '';
        document.getElementById('stat-points-comp').textContent = '';
        document.getElementById('stat-travel-comp').textContent = '';

        // Remove optimization highlighting
        document.getElementById('stat-box-paths').classList.remove('optimized');
        document.getElementById('stat-box-points').classList.remove('optimized');
        document.getElementById('stat-box-travel').classList.remove('optimized');
        document.getElementById('stat-box-time').classList.remove('optimized');
      }
    }

    function showStatus(message, type = 'info') {
      const statusEl = document.getElementById('status-message');
      statusEl.textContent = message;
      statusEl.className = `status-message ${type}`;
      statusEl.style.display = 'block';

      if (type !== 'error') {
        setTimeout(() => {
          statusEl.style.display = 'none';
        }, 3000);
      }
    }

    // Button handlers
    document.getElementById('btn-optimize').addEventListener('click', () => {
      const enabledLayers = layers.filter(l => l.enabled);
      if (enabledLayers.length === 0) {
        showStatus('Enable at least one layer to optimize', 'error');
        return;
      }

      showStatus('Optimizing paths...', 'info');

      const options = {
        merge: document.getElementById('opt-merge').checked,
        sort: document.getElementById('opt-sort').checked,
        reloop: document.getElementById('opt-reloop').checked,
        simplify: document.getElementById('opt-simplify').checked,
        tolerance: 0.5
      };

      enabledLayers.forEach(layer => {
        const optimized = optimizer.optimize(layer.paths, options);
        layer.optimizedPaths = optimized;
        layer.optimized = true;
      });

      optimizationStats = optimizer.stats;
      renderLayers();
      updateStats();
      showStatus('Optimization complete!', 'success');
    });

    document.getElementById('btn-export-svg').addEventListener('click', () => {
      if (!svgData) return;

      const enabledLayers = layers.filter(l => l.enabled);
      const svgContent = generateSVG(enabledLayers);

      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `plotter-prep-${Date.now()}.svg`;
      a.click();
      URL.revokeObjectURL(url);
      showStatus('SVG exported successfully', 'success');
    });

    document.getElementById('btn-export-layers').addEventListener('click', () => {
      const enabledLayers = layers.filter(l => l.enabled);
      if (enabledLayers.length === 0) {
        showStatus('Enable at least one layer to export', 'error');
        return;
      }

      enabledLayers.forEach(layer => {
        const svgContent = generateSVG([layer]);
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${layer.name.replace(/\s+/g, '-')}-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
      });

      showStatus(`Exported ${enabledLayers.length} layers`, 'success');
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
      if (confirm('Reset to original SVG? This will lose all optimizations.')) {
        parseSVG(originalSvgData);
        showStatus('Reset to original', 'info');
      }
    });

    function generateSVG(layersToExport) {
      let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600" viewBox="0 0 800 600">
  <rect width="800" height="600" fill="white"/>
`;

      layersToExport.forEach(layer => {
        const paths = layer.optimized && layer.optimizedPaths ? layer.optimizedPaths : layer.paths;

        paths.forEach(path => {
          const d = path.points.map((p, i) =>
            `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(2)},${p.y.toFixed(2)}`
          ).join(' ') + (path.closed ? ' Z' : '');

          svg += `  <path d="${d}" stroke="${layer.color}" fill="none" stroke-width="1"/>\n`;
        });
      });

      svg += `</svg>`;
      return svg;
    }
  </script>
</body>
</html>
