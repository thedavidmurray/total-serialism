<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <title>Path Optimizer GUI - Pen Plotter Tools</title>
    
  <!-- Total Serialism Design System -->
  <link rel="stylesheet" href="../../shared/algorithm.css">
  <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .control-group {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }
        
        input[type="number"], input[type="file"], select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .canvas-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .canvas-container h3 {
            margin-top: 0;
            color: #333;
        }
        
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }
        
        .statistics {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }
        
        .stat-change {
            font-size: 14px;
            color: #28a745;
        }
        
        .stat-change.negative {
            color: #dc3545;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .test-patterns {
            margin-top: 10px;
        }
        
        .checkbox-group {
            margin: 10px 0;
        }
        
        .checkbox-group label {
            display: inline;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Path Optimizer for Pen Plotter</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="fileInput">Load SVG or JSON:</label>
                <input type="file" id="fileInput" accept=".svg,.json">
            </div>
            
            <div class="control-group">
                <label for="testPattern">Or Generate Test Pattern:</label>
                <select id="testPattern">
                    <option value="">Select pattern...</option>
                    <option value="random">Random Paths</option>
                    <option value="grid">Grid Pattern</option>
                    <option value="circular">Circular Pattern</option>
                    <option value="clustered">Clustered Paths</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="pathCount">Path Count:</label>
                <input type="number" id="pathCount" value="50" min="1" max="1000">
            </div>
            
            <div class="control-group">
                <label for="mergeTolerance">Merge Tolerance:</label>
                <input type="number" id="mergeTolerance" value="0.1" min="0" max="10" step="0.1">
            </div>
            
            <div class="control-group">
                <label for="simplifyTolerance">Simplify Tolerance:</label>
                <input type="number" id="simplifyTolerance" value="0.5" min="0" max="10" step="0.1">
            </div>
            
            <div class="control-group">
                <label for="tspIterations">TSP Iterations:</label>
                <input type="number" id="tspIterations" value="100" min="0" max="1000">
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showTravel" checked>
                <label for="showTravel">Show Travel Lines</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showMarkers" checked>
                <label for="showMarkers">Show Start/End Markers</label>
            </div>
            
            <div style="margin-top: 20px;">
                <button id="optimizeBtn">Optimize Paths</button>
                <button id="exportSVGBtn" disabled>Export SVG</button>
                <button id="exportGCodeBtn" disabled>Export G-Code</button>
                <button id="exportJSONBtn" disabled>Export JSON</button>
            </div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div class="visualization">
            <div class="canvas-container">
                <h3>Original Paths</h3>
                <canvas id="originalCanvas" width="600" height="600"></canvas>
            </div>
            
            <div class="canvas-container">
                <h3>Optimized Paths</h3>
                <canvas id="optimizedCanvas" width="600" height="600"></canvas>
            </div>
        </div>
        
        <div class="statistics">
            <h3>Optimization Statistics</h3>
            <div class="stat-grid" id="statsGrid">
                <div class="loading">Load or generate paths to see statistics</div>
            </div>
        </div>
    </div>

    <script src="../../../../path-optimizer.js"></script>
    <!-- TODO: Missing optimizer-utils.js - needs to be created -->
    <!-- <script src="../../src/optimization/optimizer-utils.js"></script> -->
    <script>
        // Global variables
        let originalPaths = [];
        let optimizedPaths = [];
        let optimizer = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            optimizer = new PathOptimizer({
                mergeTolerance: parseFloat(document.getElementById('mergeTolerance').value),
                simplifyTolerance: parseFloat(document.getElementById('simplifyTolerance').value),
                tspIterations: parseInt(document.getElementById('tspIterations').value)
            });
            
            // Event listeners
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('testPattern').addEventListener('change', generateTestPattern);
            document.getElementById('optimizeBtn').addEventListener('click', optimizePaths);
            document.getElementById('exportSVGBtn').addEventListener('click', () => exportPaths('svg'));
            document.getElementById('exportGCodeBtn').addEventListener('click', () => exportPaths('gcode'));
            document.getElementById('exportJSONBtn').addEventListener('click', () => exportPaths('json'));
            
            // Update optimizer settings
            ['mergeTolerance', 'simplifyTolerance', 'tspIterations'].forEach(id => {
                document.getElementById(id).addEventListener('change', updateOptimizerSettings);
            });
            
            // Update visualization settings
            ['showTravel', 'showMarkers'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    if (originalPaths.length > 0) visualizePaths();
                });
            });
        });
        
        function updateOptimizerSettings() {
            optimizer.options.mergeTolerance = parseFloat(document.getElementById('mergeTolerance').value);
            optimizer.options.simplifyTolerance = parseFloat(document.getElementById('simplifyTolerance').value);
            optimizer.options.tspIterations = parseInt(document.getElementById('tspIterations').value);
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    if (file.name.endsWith('.json')) {
                        originalPaths = JSON.parse(e.target.result);
                    } else if (file.name.endsWith('.svg')) {
                        originalPaths = parseSVG(e.target.result);
                    }
                    
                    optimizedPaths = [];
                    visualizePaths();
                    updateStatistics();
                    document.getElementById('optimizeBtn').disabled = false;
                    hideError();
                } catch (error) {
                    showError(`Error loading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }
        
        function parseSVG(svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const paths = [];
            
            // Parse path elements
            doc.querySelectorAll('path').forEach(pathElement => {
                const d = pathElement.getAttribute('d');
                if (!d) return;
                
                const points = [];
                const commands = d.match(/[MLHVCSQTAZmlhvcsqtaz][^MLHVCSQTAZmlhvcsqtaz]*/g);
                let currentX = 0, currentY = 0;
                
                commands.forEach(cmd => {
                    const type = cmd[0];
                    const coords = cmd.substring(1).trim().split(/[\s,]+/).map(parseFloat);
                    
                    switch (type.toUpperCase()) {
                        case 'M':
                            currentX = type === 'M' ? coords[0] : currentX + coords[0];
                            currentY = type === 'M' ? coords[1] : currentY + coords[1];
                            points.push({ x: currentX, y: currentY });
                            break;
                        case 'L':
                            currentX = type === 'L' ? coords[0] : currentX + coords[0];
                            currentY = type === 'L' ? coords[1] : currentY + coords[1];
                            points.push({ x: currentX, y: currentY });
                            break;
                        case 'H':
                            currentX = type === 'H' ? coords[0] : currentX + coords[0];
                            points.push({ x: currentX, y: currentY });
                            break;
                        case 'V':
                            currentY = type === 'V' ? coords[0] : currentY + coords[0];
                            points.push({ x: currentX, y: currentY });
                            break;
                        // Add more SVG commands as needed
                    }
                });
                
                if (points.length > 0) {
                    paths.push({
                        points,
                        color: pathElement.getAttribute('stroke') || 'black'
                    });
                }
            });
            
            return paths;
        }
        
        function generateTestPattern() {
            const pattern = document.getElementById('testPattern').value;
            if (!pattern) return;
            
            const count = parseInt(document.getElementById('pathCount').value);
            
            try {
                originalPaths = OptimizerUtils.generateTestPaths(pattern, count, {
                    width: 600,
                    height: 600,
                    colors: ['black', 'red', 'blue', 'green']
                });
                
                optimizedPaths = [];
                visualizePaths();
                updateStatistics();
                document.getElementById('optimizeBtn').disabled = false;
                hideError();
            } catch (error) {
                showError(`Error generating pattern: ${error.message}`);
            }
        }
        
        function optimizePaths() {
            if (originalPaths.length === 0) return;
            
            try {
                showLoading();
                
                // Run optimization
                const result = optimizer.optimize(originalPaths);
                optimizedPaths = result.paths;
                
                // Visualize and update stats
                visualizePaths();
                updateStatistics(result.statistics);
                
                // Enable export buttons
                document.getElementById('exportSVGBtn').disabled = false;
                document.getElementById('exportGCodeBtn').disabled = false;
                document.getElementById('exportJSONBtn').disabled = false;
                
                hideError();
            } catch (error) {
                showError(`Optimization error: ${error.message}`);
            }
        }
        
        function visualizePaths() {
            const showTravel = document.getElementById('showTravel').checked;
            const showMarkers = document.getElementById('showMarkers').checked;
            
            // Visualize original paths
            if (originalPaths.length > 0) {
                const originalViz = OptimizerUtils.createVisualization(originalPaths, {
                    width: 600,
                    height: 600,
                    showTravel,
                    showStartEnd: showMarkers
                });
                drawVisualization('originalCanvas', originalViz);
            }
            
            // Visualize optimized paths
            if (optimizedPaths.length > 0) {
                const optimizedViz = OptimizerUtils.createVisualization(optimizedPaths, {
                    width: 600,
                    height: 600,
                    showTravel,
                    showStartEnd: showMarkers
                });
                drawVisualization('optimizedCanvas', optimizedViz);
            }
        }
        
        function drawVisualization(canvasId, viz) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!viz) return;
            
            // Draw travel lines
            if (viz.travels.length > 0) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                
                viz.travels.forEach(travel => {
                    ctx.beginPath();
                    ctx.moveTo(travel.start.x, travel.start.y);
                    ctx.lineTo(travel.end.x, travel.end.y);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
            }
            
            // Draw paths
            viz.paths.forEach((path, index) => {
                ctx.strokeStyle = getColorForPath(path.color, index);
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                path.points.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            });
            
            // Draw markers
            viz.markers.forEach(marker => {
                if (marker.type === 'start') {
                    ctx.fillStyle = 'green';
                    ctx.beginPath();
                    ctx.arc(marker.position.x, marker.position.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (marker.type === 'end') {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(marker.position.x - 3, marker.position.y - 3, 6, 6);
                }
            });
        }
        
        function getColorForPath(color, index) {
            const colors = {
                'black': '#000000',
                'red': '#ff0000',
                'blue': '#0000ff',
                'green': '#00ff00',
                'default': '#000000'
            };
            
            if (colors[color]) return colors[color];
            if (color && color.startsWith('#')) return color;
            if (color && color.startsWith('rgb')) return color;
            
            // Generate color based on index
            const hue = (index * 137.5) % 360;  // Golden angle
            return `hsl(${hue}, 70%, 50%)`;
        }
        
        function updateStatistics(optimizationStats) {
            const statsGrid = document.getElementById('statsGrid');
            
            if (!originalPaths.length && !optimizedPaths.length) {
                statsGrid.innerHTML = '<div class="loading">Load or generate paths to see statistics</div>';
                return;
            }
            
            const originalStats = OptimizerUtils.analyzePaths(originalPaths);
            const optimizedStats = optimizedPaths.length > 0 ? 
                OptimizerUtils.analyzePaths(optimizedPaths) : null;
            
            let html = '';
            
            // Path count
            html += createStatCard('Path Count', 
                originalStats.pathCount, 
                optimizedStats?.pathCount,
                'paths');
            
            // Total points
            html += createStatCard('Total Points', 
                originalStats.totalPoints, 
                optimizedStats?.totalPoints,
                'points');
            
            // Travel distance
            html += createStatCard('Travel Distance', 
                originalStats.travelDistance.toFixed(1), 
                optimizedStats?.travelDistance.toFixed(1),
                'units');
            
            // Pen lifts
            html += createStatCard('Pen Lifts', 
                originalStats.penLifts, 
                optimizedStats?.penLifts,
                'lifts');
            
            // Total length
            html += createStatCard('Total Drawing', 
                originalStats.totalLength.toFixed(1), 
                optimizedStats?.totalLength.toFixed(1),
                'units');
            
            // Efficiency
            html += createStatCard('Efficiency', 
                (originalStats.efficiency * 100).toFixed(1) + '%', 
                optimizedStats ? (optimizedStats.efficiency * 100).toFixed(1) + '%' : null);
            
            // Colors
            html += createStatCard('Colors/Tools', 
                originalStats.colors.size, 
                optimizedStats?.colors.size,
                'colors');
            
            // Optimization time
            if (optimizationStats?.optimizationTime) {
                html += createStatCard('Optimization Time', 
                    null,
                    optimizationStats.optimizationTime.toFixed(1) + 'ms');
            }
            
            statsGrid.innerHTML = html;
        }
        
        function createStatCard(label, originalValue, optimizedValue, unit = '') {
            let changeHtml = '';
            
            if (optimizedValue !== null && optimizedValue !== undefined && originalValue !== null) {
                const originalNum = parseFloat(originalValue);
                const optimizedNum = parseFloat(optimizedValue);
                
                if (!isNaN(originalNum) && !isNaN(optimizedNum)) {
                    const change = originalNum - optimizedNum;
                    const changePercent = originalNum > 0 ? (change / originalNum * 100) : 0;
                    
                    if (Math.abs(changePercent) > 0.1) {
                        const isPositive = change > 0;
                        changeHtml = `<div class="stat-change ${!isPositive ? 'negative' : ''}">
                            ${isPositive ? '↓' : '↑'} ${Math.abs(changePercent).toFixed(1)}%
                        </div>`;
                    }
                }
            }
            
            const displayValue = optimizedValue !== null && optimizedValue !== undefined ? 
                optimizedValue : originalValue;
            
            return `
                <div class="stat-card">
                    <div class="stat-label">${label}</div>
                    <div class="stat-value">${displayValue}</div>
                    ${changeHtml}
                </div>
            `;
        }
        
        function exportPaths(format) {
            if (optimizedPaths.length === 0) return;
            
            try {
                let content, filename, mimeType;
                
                switch (format) {
                    case 'svg':
                        content = optimizer.exportSVG(optimizedPaths, 600, 600);
                        filename = 'optimized-paths.svg';
                        mimeType = 'image/svg+xml';
                        break;
                    
                    case 'gcode':
                        content = optimizer.exportGCode(optimizedPaths, {
                            feedRate: 1000,
                            scale: 0.1  // Scale down for typical plotter
                        });
                        filename = 'optimized-paths.gcode';
                        mimeType = 'text/plain';
                        break;
                    
                    case 'json':
                        content = optimizer.exportPaths(optimizedPaths, 'json');
                        filename = 'optimized-paths.json';
                        mimeType = 'application/json';
                        break;
                }
                
                // Download file
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
            } catch (error) {
                showError(`Export error: ${error.message}`);
            }
        }
        
        function showLoading() {
            document.getElementById('statsGrid').innerHTML = 
                '<div class="loading">Optimizing paths...</div>';
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
    </script>
</body>
</html>