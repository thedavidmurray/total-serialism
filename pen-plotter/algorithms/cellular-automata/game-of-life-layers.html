<!DOCTYPE html>
<html>
<head>
  <title>Game of Life - Multi-Layer Edition</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      background: #1a1a1a;
      color: #fff;
    }
    #canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #2a2a2a;
      position: relative;
    }
    #controls {
      width: 350px;
      padding: 20px;
      background: #1a1a1a;
      height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    h2 {
      margin: 0 0 20px 0;
      color: #4CAF50;
    }
    .control-group {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #333;
    }
    .control-group h3 {
      margin: 0 0 15px 0;
      color: #4CAF50;
      font-size: 16px;
    }
    .control {
      margin-bottom: 12px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      color: #ccc;
    }
    input[type="range"] {
      width: 100%;
    }
    select {
      width: 100%;
      padding: 5px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }
    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      background: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
      border-radius: 4px;
    }
    button:hover {
      background: #45a049;
    }
    .secondary {
      background: #555;
    }
    .secondary:hover {
      background: #666;
    }
    .value {
      font-weight: bold;
      color: #4CAF50;
    }
    #generation {
      text-align: center;
      font-size: 18px;
      color: #4CAF50;
      margin: 10px 0;
    }
    .layer-control {
      background: #333;
      padding: 10px;
      margin: 5px 0;
      border-radius: 4px;
    }
    .layer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .layer-name {
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    .color-box {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border: 1px solid #fff;
      display: inline-block;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
    }
    .checkbox-container input {
      margin-right: 10px;
    }
    input[type="color"] {
      width: 50px;
      height: 30px;
      border: none;
      cursor: pointer;
    }
    .rule-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .rule-input {
      display: flex;
      align-items: center;
      font-size: 12px;
    }
    .rule-input input {
      width: 50px;
      margin-left: 5px;
      padding: 2px;
      background: #444;
      color: #fff;
      border: 1px solid #666;
    }
    #layer-preview {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 4px;
    }
    .preview-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      font-size: 12px;
    }
    .export-btn {
      background: #2196F3;
    }
    .export-btn:hover {
      background: #1976D2;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <div id="layer-preview"></div>
  </div>
  <div id="controls">
    <h2>Multi-Layer Life</h2>
    
    <div id="generation">Generation: 0</div>
    
    <div class="control-group">
      <h3>Simulation</h3>
      <button id="play-pause">▶ Play</button>
      <button id="step" class="secondary">Step Forward</button>
      <button id="reset" class="secondary">Reset</button>
      <button id="clear" class="secondary">Clear All Layers</button>
    </div>
    
    <div class="control-group">
      <h3>Drawing</h3>
      <div class="control">
        <label>Draw on Layer:</label>
        <select id="draw-layer-select">
          <!-- Options will be populated dynamically -->
        </select>
      </div>
      <div style="font-size: 12px; color: #888; margin-top: 10px;">
        • Left click: Draw cells<br>
        • Right click: Erase cells<br>
        • Number keys 1-4: Quick layer select
      </div>
    </div>
    
    <div class="control-group">
      <h3>Grid Settings</h3>
      <div class="control">
        <label>Grid Size: <span class="value" id="gridSize-val">50</span></label>
        <input type="range" id="gridSize" min="20" max="150" value="50">
      </div>
      <div class="control">
        <label>Cell Size: <span class="value" id="cellSize-val">10</span>px</label>
        <input type="range" id="cellSize" min="3" max="20" value="10">
      </div>
      <div class="control">
        <label>Speed: <span class="value" id="speed-val">5</span> fps</label>
        <input type="range" id="speed" min="1" max="30" value="5">
      </div>
    </div>
    
    <div class="control-group">
      <h3>Layers</h3>
      <div id="layers-container"></div>
      <button onclick="addLayer()" class="secondary">+ Add Layer</button>
    </div>
    
    <div class="control-group">
      <h3>Presets</h3>
      <button onclick="loadPreset('twoSpecies')">Two Species Competition</button>
      <button onclick="loadPreset('threeLayer')">Three Layer Ecosystem</button>
      <button onclick="loadPreset('rainbow')">Rainbow Cascade</button>
      <button onclick="loadPreset('lifeWar')">Life War (4 Teams)</button>
    </div>
    
    <div class="control-group">
      <h3>Export Options</h3>
      <button class="export-btn" onclick="exportAllLayers()">Export All Layers (ZIP)</button>
      <button class="export-btn" onclick="exportCombined()">Export Combined SVG</button>
      <button class="export-btn" onclick="exportLayersSeparately()">Export Each Layer</button>
      <button class="export-btn" onclick="exportGIF()">Export as GIF</button>
      <div class="control checkbox-container">
        <input type="checkbox" id="includeRegistration" checked>
        <label for="includeRegistration">Include Registration Marks</label>
      </div>
      <div id="gif-status" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
    </div>
  </div>

  <script>
    // Multi-layer Game of Life
    let layers = [];
    let generation = 0;
    let isPlaying = false;
    let lastUpdate = 0;
    let gridSize = 50;
    let cellSize = 10;
    let speed = 5;
    let currentDrawLayer = 0; // Layer ID to draw on
    
    // Layer class
    class Layer {
      constructor(id, name, color, birthRules, survivalRules) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.birthRules = birthRules;
        this.survivalRules = survivalRules;
        this.grid = [];
        this.nextGrid = [];
        this.visible = true;
        this.opacity = 1.0;
        this.interaction = 'independent'; // 'independent', 'competitive', 'cooperative'
        this.initializeGrid();
      }
      
      initializeGrid() {
        this.grid = [];
        this.nextGrid = [];
        for (let i = 0; i < gridSize; i++) {
          this.grid[i] = [];
          this.nextGrid[i] = [];
          for (let j = 0; j < gridSize; j++) {
            this.grid[i][j] = 0;
            this.nextGrid[i][j] = 0;
          }
        }
      }
      
      countNeighbors(x, y, includeOtherLayers = false) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue;
            
            let nx = (x + i + gridSize) % gridSize;
            let ny = (y + j + gridSize) % gridSize;
            
            count += this.grid[nx][ny];
            
            // Count cells from other layers if interaction enabled
            if (includeOtherLayers && this.interaction !== 'independent') {
              layers.forEach(layer => {
                if (layer.id !== this.id && layer.visible) {
                  if (this.interaction === 'competitive' && layer.grid[nx][ny]) {
                    count -= 0.5; // Other species inhibit growth
                  } else if (this.interaction === 'cooperative' && layer.grid[nx][ny]) {
                    count += 0.5; // Other species promote growth
                  }
                }
              });
            }
          }
        }
        return Math.floor(count);
      }
      
      step() {
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const neighbors = this.countNeighbors(i, j, true);
            
            if (this.grid[i][j] === 1) {
              // Check survival
              this.nextGrid[i][j] = this.survivalRules.includes(neighbors) ? 1 : 0;
            } else {
              // Check birth
              this.nextGrid[i][j] = this.birthRules.includes(neighbors) ? 1 : 0;
              
              // Prevent birth if another layer occupies the cell (competitive)
              if (this.interaction === 'competitive' && this.nextGrid[i][j] === 1) {
                for (let layer of layers) {
                  if (layer.id !== this.id && layer.grid[i][j] === 1) {
                    this.nextGrid[i][j] = 0;
                    break;
                  }
                }
              }
            }
          }
        }
        
        // Swap grids
        let temp = this.grid;
        this.grid = this.nextGrid;
        this.nextGrid = temp;
      }
    }
    
    function setup() {
      let canvas = createCanvas(800, 600);
      canvas.parent('canvas-container');
      
      setupControls();
      
      // Initialize with two default layers
      layers.push(new Layer(0, 'Species A', '#4CAF50', [3], [2, 3]));
      layers.push(new Layer(1, 'Species B', '#2196F3', [3], [2, 3]));
      
      updateLayerControls();
      updateLayerPreview();
      updateDrawLayerSelect();
      
      // Load first preset
      loadPreset('twoSpecies');
    }
    
    function setupControls() {
      // Play/Pause
      document.getElementById('play-pause').addEventListener('click', () => {
        isPlaying = !isPlaying;
        document.getElementById('play-pause').textContent = isPlaying ? '⏸ Pause' : '▶ Play';
      });
      
      // Step
      document.getElementById('step').addEventListener('click', () => {
        stepSimulation();
      });
      
      // Reset
      document.getElementById('reset').addEventListener('click', () => {
        generation = 0;
        updateGenerationDisplay();
        layers.forEach(layer => layer.initializeGrid());
      });
      
      // Clear
      document.getElementById('clear').addEventListener('click', () => {
        layers.forEach(layer => layer.initializeGrid());
        generation = 0;
        updateGenerationDisplay();
      });
      
      // Grid controls
      document.getElementById('gridSize').addEventListener('input', (e) => {
        gridSize = parseInt(e.target.value);
        document.getElementById('gridSize-val').textContent = gridSize;
        layers.forEach(layer => layer.initializeGrid());
      });
      
      document.getElementById('cellSize').addEventListener('input', (e) => {
        cellSize = parseInt(e.target.value);
        document.getElementById('cellSize-val').textContent = cellSize;
      });
      
      document.getElementById('speed').addEventListener('input', (e) => {
        speed = parseInt(e.target.value);
        document.getElementById('speed-val').textContent = speed;
      });
      
      // Draw layer select
      document.getElementById('draw-layer-select').addEventListener('change', (e) => {
        currentDrawLayer = parseInt(e.target.value);
      });
    }
    
    function draw() {
      background(30);
      
      // Update simulation
      if (isPlaying && millis() - lastUpdate > 1000 / speed) {
        stepSimulation();
        lastUpdate = millis();
      }
      
      // Calculate drawing parameters
      const offsetX = (width - gridSize * cellSize) / 2;
      const offsetY = (height - gridSize * cellSize) / 2;
      
      // Draw grid
      stroke(50);
      strokeWeight(0.5);
      for (let i = 0; i <= gridSize; i++) {
        line(offsetX + i * cellSize, offsetY, 
             offsetX + i * cellSize, offsetY + gridSize * cellSize);
        line(offsetX, offsetY + i * cellSize, 
             offsetX + gridSize * cellSize, offsetY + i * cellSize);
      }
      
      // Draw layers
      layers.forEach(layer => {
        if (!layer.visible) return;
        
        const c = color(layer.color);
        c.setAlpha(layer.opacity * 255);
        fill(c);
        noStroke();
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            if (layer.grid[i][j] === 1) {
              const x = offsetX + i * cellSize;
              const y = offsetY + j * cellSize;
              rect(x, y, cellSize, cellSize);
            }
          }
        }
      });
      
      // Draw layer indicator
      drawLayerIndicator(offsetX, offsetY);
    }
    
    function stepSimulation() {
      layers.forEach(layer => layer.step());
      generation++;
      updateGenerationDisplay();
    }
    
    // Mouse interaction functions
    function mousePressed() {
      drawCell();
    }
    
    function mouseDragged() {
      drawCell();
    }
    
    function drawCell() {
      const offsetX = (width - gridSize * cellSize) / 2;
      const offsetY = (height - gridSize * cellSize) / 2;
      const gridX = Math.floor((mouseX - offsetX) / cellSize);
      const gridY = Math.floor((mouseY - offsetY) / cellSize);
      
      if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
        const layer = layers.find(l => l.id === currentDrawLayer);
        if (layer) {
          layer.grid[gridX][gridY] = mouseButton === LEFT ? 1 : 0;
        }
      }
    }
    
    function keyPressed() {
      // Number keys 1-4 for quick layer selection
      if (key >= '1' && key <= '4') {
        const layerIndex = parseInt(key) - 1;
        if (layerIndex < layers.length) {
          currentDrawLayer = layers[layerIndex].id;
          updateDrawLayerSelect();
        }
      }
    }
    
    function drawLayerIndicator(offsetX, offsetY) {
      const layer = layers.find(l => l.id === currentDrawLayer);
      if (!layer) return;
      
      // Draw border around grid to show active layer
      push();
      stroke(layer.color);
      strokeWeight(3);
      noFill();
      rect(offsetX - 2, offsetY - 2, gridSize * cellSize + 4, gridSize * cellSize + 4);
      
      // Draw layer info
      fill(layer.color);
      noStroke();
      textAlign(LEFT, TOP);
      textSize(14);
      text(`Drawing on: ${layer.name}`, offsetX, offsetY - 20);
      pop();
    }
    
    function updateDrawLayerSelect() {
      const select = document.getElementById('draw-layer-select');
      select.innerHTML = '';
      
      layers.forEach(layer => {
        const option = document.createElement('option');
        option.value = layer.id;
        option.textContent = layer.name;
        option.style.color = layer.color;
        if (layer.id === currentDrawLayer) {
          option.selected = true;
        }
        select.appendChild(option);
      });
    }
    
    function updateGenerationDisplay() {
      document.getElementById('generation').textContent = `Generation: ${generation}`;
    }
    
    function addLayer() {
      const id = layers.length;
      const colors = ['#FF6B6B', '#FFE66D', '#8E7CC3', '#FF8C94', '#98D8C8'];
      const color = colors[id % colors.length];
      const layer = new Layer(id, `Layer ${id + 1}`, color, [3], [2, 3]);
      layers.push(layer);
      updateLayerControls();
      updateLayerPreview();
      updateDrawLayerSelect();
    }
    
    function removeLayer(id) {
      layers = layers.filter(l => l.id !== id);
      // If we removed the current draw layer, select the first available
      if (!layers.find(l => l.id === currentDrawLayer) && layers.length > 0) {
        currentDrawLayer = layers[0].id;
      }
      updateLayerControls();
      updateLayerPreview();
      updateDrawLayerSelect();
    }
    
    function updateLayerControls() {
      const container = document.getElementById('layers-container');
      container.innerHTML = '';
      
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'layer-control';
        div.innerHTML = `
          <div class="layer-header">
            <div class="layer-name">
              <span class="color-box" style="background: ${layer.color}"></span>
              <input type="text" value="${layer.name}" onchange="updateLayerName(${layer.id}, this.value)" style="background: #444; color: #fff; border: 1px solid #666; padding: 2px;">
            </div>
            <div>
              <input type="checkbox" ${layer.visible ? 'checked' : ''} onchange="toggleLayerVisibility(${layer.id})">
              <input type="color" value="${layer.color}" onchange="updateLayerColor(${layer.id}, this.value)">
              <button onclick="removeLayer(${layer.id})" style="width: auto; padding: 5px 10px; margin: 0;">×</button>
            </div>
          </div>
          <div class="rule-inputs">
            <div class="rule-input">
              Birth: <input type="text" value="${layer.birthRules.join(',')}" onchange="updateBirthRules(${layer.id}, this.value)">
            </div>
            <div class="rule-input">
              Survive: <input type="text" value="${layer.survivalRules.join(',')}" onchange="updateSurvivalRules(${layer.id}, this.value)">
            </div>
          </div>
          <div style="margin-top: 10px;">
            <label style="font-size: 12px;">Interaction:</label>
            <select onchange="updateLayerInteraction(${layer.id}, this.value)" style="font-size: 12px;">
              <option value="independent" ${layer.interaction === 'independent' ? 'selected' : ''}>Independent</option>
              <option value="competitive" ${layer.interaction === 'competitive' ? 'selected' : ''}>Competitive</option>
              <option value="cooperative" ${layer.interaction === 'cooperative' ? 'selected' : ''}>Cooperative</option>
            </select>
          </div>
        `;
        container.appendChild(div);
      });
    }
    
    function updateLayerPreview() {
      const preview = document.getElementById('layer-preview');
      preview.innerHTML = '<h4 style="margin: 0 0 10px 0; font-size: 14px;">Active Layers</h4>';
      
      layers.filter(l => l.visible).forEach(layer => {
        const div = document.createElement('div');
        div.className = 'preview-item';
        div.innerHTML = `
          <span class="color-box" style="background: ${layer.color}; width: 15px; height: 15px;"></span>
          <span>${layer.name}</span>
        `;
        preview.appendChild(div);
      });
    }
    
    // Layer update functions
    function updateLayerName(id, name) {
      const layer = layers.find(l => l.id === id);
      if (layer) layer.name = name;
      updateLayerPreview();
    }
    
    function updateLayerColor(id, color) {
      const layer = layers.find(l => l.id === id);
      if (layer) layer.color = color;
      updateLayerControls();
      updateLayerPreview();
    }
    
    function toggleLayerVisibility(id) {
      const layer = layers.find(l => l.id === id);
      if (layer) layer.visible = !layer.visible;
      updateLayerPreview();
    }
    
    function updateBirthRules(id, rulesStr) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer.birthRules = rulesStr.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
      }
    }
    
    function updateSurvivalRules(id, rulesStr) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer.survivalRules = rulesStr.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
      }
    }
    
    function updateLayerInteraction(id, interaction) {
      const layer = layers.find(l => l.id === id);
      if (layer) layer.interaction = interaction;
    }
    
    // Presets
    function loadPreset(name) {
      generation = 0;
      updateGenerationDisplay();
      
      switch (name) {
        case 'twoSpecies':
          layers = [
            new Layer(0, 'Predator', '#FF6B6B', [3], [2, 3]),
            new Layer(1, 'Prey', '#4CAF50', [3], [2, 3])
          ];
          layers[0].interaction = 'competitive';
          layers[1].interaction = 'competitive';
          
          // Random initial state
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              if (random() < 0.2) layers[0].grid[i][j] = 1;
              else if (random() < 0.3) layers[1].grid[i][j] = 1;
            }
          }
          break;
          
        case 'threeLayer':
          layers = [
            new Layer(0, 'Red Colony', '#FF6B6B', [3], [2, 3]),
            new Layer(1, 'Green Colony', '#4CAF50', [3], [2, 3]),
            new Layer(2, 'Blue Colony', '#2196F3', [3], [2, 3])
          ];
          layers.forEach(l => l.interaction = 'competitive');
          
          // Three starting colonies
          const centers = [[15, 15], [35, 15], [25, 35]];
          centers.forEach((center, idx) => {
            for (let i = -3; i <= 3; i++) {
              for (let j = -3; j <= 3; j++) {
                if (random() < 0.5) {
                  const x = center[0] + i;
                  const y = center[1] + j;
                  if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                    layers[idx].grid[x][y] = 1;
                  }
                }
              }
            }
          });
          break;
          
        case 'rainbow':
          layers = [];
          const rainbowColors = ['#FF0000', '#FF8800', '#FFFF00', '#00FF00', '#0088FF', '#8800FF'];
          rainbowColors.forEach((color, idx) => {
            const layer = new Layer(idx, `Wave ${idx + 1}`, color, [3], [2, 3]);
            layer.interaction = 'cooperative';
            layers.push(layer);
          });
          
          // Cascading start
          layers.forEach((layer, idx) => {
            const y = Math.floor(gridSize / 2);
            for (let x = idx * 8; x < idx * 8 + 5 && x < gridSize; x++) {
              layer.grid[x][y] = 1;
              if (y > 0) layer.grid[x][y-1] = 1;
              if (y < gridSize-1) layer.grid[x][y+1] = 1;
            }
          });
          break;
          
        case 'lifeWar':
          layers = [
            new Layer(0, 'North', '#FF6B6B', [3], [2, 3]),
            new Layer(1, 'South', '#4CAF50', [3], [2, 3]),
            new Layer(2, 'East', '#2196F3', [3], [2, 3]),
            new Layer(3, 'West', '#FFE66D', [3], [2, 3])
          ];
          layers.forEach(l => l.interaction = 'competitive');
          
          // Four corners start
          const corners = [
            [0, 0], [gridSize-10, gridSize-10], 
            [gridSize-10, 0], [0, gridSize-10]
          ];
          corners.forEach((corner, idx) => {
            for (let i = 0; i < 10; i++) {
              for (let j = 0; j < 10; j++) {
                if (random() < 0.5) {
                  const x = corner[0] + i;
                  const y = corner[1] + j;
                  if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                    layers[idx].grid[x][y] = 1;
                  }
                }
              }
            }
          });
          break;
      }
      
      // Set current draw layer to first layer
      if (layers.length > 0) {
        currentDrawLayer = layers[0].id;
      }
      
      updateLayerControls();
      updateLayerPreview();
      updateDrawLayerSelect();
    }
    
    // Export functions
    function exportLayersSeparately() {
      layers.forEach(layer => {
        if (!layer.visible) return;
        
        let svg = createGraphics(gridSize * 10 + 40, gridSize * 10 + 40, SVG);
        svg.background(255);
        
        // Registration marks
        if (document.getElementById('includeRegistration').checked) {
          svg.stroke(0);
          svg.strokeWeight(1);
          svg.noFill();
          // Corner marks
          svg.line(5, 10, 15, 10);
          svg.line(10, 5, 10, 15);
          svg.line(svg.width - 15, 10, svg.width - 5, 10);
          svg.line(svg.width - 10, 5, svg.width - 10, 15);
          svg.line(5, svg.height - 10, 15, svg.height - 10);
          svg.line(10, svg.height - 15, 10, svg.height - 5);
          svg.line(svg.width - 15, svg.height - 10, svg.width - 5, svg.height - 10);
          svg.line(svg.width - 10, svg.height - 15, svg.width - 10, svg.height - 5);
        }
        
        // Draw cells
        svg.fill(0);
        svg.noStroke();
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            if (layer.grid[i][j] === 1) {
              svg.rect(20 + i * 10, 20 + j * 10, 10, 10);
            }
          }
        }
        
        // Add metadata
        svg.push();
        svg.stroke(0);
        svg.strokeWeight(0.5);
        svg.textSize(8);
        svg.text(`Layer: ${layer.name}`, 20, svg.height - 5);
        svg.text(`Color: ${layer.color}`, 100, svg.height - 5);
        svg.text(`Gen: ${generation}`, 200, svg.height - 5);
        svg.pop();
        
        save(svg, `game-of-life-${layer.name.replace(/\s+/g, '-')}-gen${generation}.svg`);
        svg.remove();
      });
    }
    
    function exportCombined() {
      let svg = createGraphics(gridSize * 10 + 40, gridSize * 10 + 40, SVG);
      svg.background(255);
      
      // Registration marks
      if (document.getElementById('includeRegistration').checked) {
        svg.stroke(0);
        svg.strokeWeight(1);
        svg.noFill();
        // Corner marks
        svg.line(5, 10, 15, 10);
        svg.line(10, 5, 10, 15);
        svg.line(svg.width - 15, 10, svg.width - 5, 10);
        svg.line(svg.width - 10, 5, svg.width - 10, 15);
        svg.line(5, svg.height - 10, 15, svg.height - 10);
        svg.line(10, svg.height - 15, 10, svg.height - 5);
        svg.line(svg.width - 15, svg.height - 10, svg.width - 5, svg.height - 10);
        svg.line(svg.width - 10, svg.height - 15, svg.width - 10, svg.height - 5);
      }
      
      // Draw each layer with transparency
      layers.forEach(layer => {
        if (!layer.visible) return;
        
        svg.fill(layer.color);
        svg.noStroke();
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            if (layer.grid[i][j] === 1) {
              svg.rect(20 + i * 10, 20 + j * 10, 10, 10);
            }
          }
        }
      });
      
      save(svg, `game-of-life-combined-gen${generation}.svg`);
      svg.remove();
    }
    
    function exportAllLayers() {
      // In a real implementation, this would create a ZIP file
      alert('ZIP export would package all layers with a manifest file. For now, use "Export Each Layer".');
    }
    
    function exportGIF() {
      const statusEl = document.getElementById('gif-status');
      statusEl.textContent = 'Preparing GIF export...';
      
      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: width,
        height: height,
        workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
      });
      
      // Store original state
      const originalRunning = running;
      const originalGeneration = generation;
      const originalLayers = layers.map(layer => ({
        ...layer,
        grid: layer.grid.map(row => [...row])
      }));
      
      running = false;
      
      // Reset all layers
      layers.forEach(layer => {
        clearLayer(layer);
        initializeLayer(layer);
      });
      generation = 0;
      
      // Generate frames
      const totalFrames = 50;
      for (let frame = 0; frame < totalFrames; frame++) {
        statusEl.textContent = `Rendering frame ${frame + 1}/${totalFrames}...`;
        
        // Create offscreen canvas
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = width;
        offscreenCanvas.height = height;
        const ctx = offscreenCanvas.getContext('2d');
        
        // Draw background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        
        const cellSize = width / gridSize;
        
        // Draw all visible layers
        layers.forEach(layer => {
          if (layer.visible) {
            ctx.globalAlpha = 1.0;
            const col = layer.color;
            ctx.fillStyle = `rgb(${col.levels[0]}, ${col.levels[1]}, ${col.levels[2]})`;
            
            for (let i = 0; i < gridSize; i++) {
              for (let j = 0; j < gridSize; j++) {
                if (layer.grid[i][j] === 1) {
                  ctx.fillRect(i * cellSize, j * cellSize, cellSize - 1, cellSize - 1);
                }
              }
            }
          }
        });
        
        // Add frame
        gif.addFrame(ctx, {delay: 100});
        
        // Update all layers for next frame
        if (frame < totalFrames - 1) {
          layers.forEach(layer => {
            if (layer.active) {
              updateLayer(layer);
            }
          });
          generation++;
        }
      }
      
      // Restore original state
      layers = originalLayers;
      generation = originalGeneration;
      running = originalRunning;
      
      statusEl.textContent = 'Encoding GIF...';
      
      gif.on('finished', function(blob) {
        statusEl.textContent = 'GIF export complete!';
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `game-of-life-layers.gif`;
        link.click();
        
        setTimeout(() => {
          statusEl.textContent = '';
        }, 3000);
      });
      
      gif.render();
    }
  </script>
</body>
</html>